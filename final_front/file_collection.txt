CODE COLLECTION GENERATED ON 2025-04-29 14:14:53
Root directory: C:\Users\prath\Desktop\infoviz\project - Copy\final_front
================================================================================

FILE: charts.js
LINES: 1798
--------------------------------------------------------------------------------

/**
 * Chart creation and updates for NYC Urban Rhythm
 */

// Chart instances
let charts = {
    trends: null,
    dow: null,
    hour: null,
    proportion: null,
    categories: null,
    transitBorough: null,
    transitTime: null,
    taxiTime: null,
    taxiDistance: null,
    taxiLocations: null,
    eventsBorough: null,
    eventsType: null,
    transit311: null,
    eventsImpact: null,
    taxi311: null,
    correlationMatrix: null,
    temp: null,
    precip: null
};

/**
 * Initialize all charts
 */
function initializeCharts() {
    // Set Chart.js defaults
    Chart.defaults.font.family = "'Inter', sans-serif";
    Chart.defaults.font.size = 12;
    Chart.defaults.color = '#4B5563';
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    Chart.defaults.plugins.tooltip.titleColor = '#111827';
    Chart.defaults.plugins.tooltip.bodyColor = '#4B5563';
    Chart.defaults.plugins.tooltip.borderColor = '#E5E7EB';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.displayColors = true;
}

/**
 * Update all charts based on processed data
 */
function updateAllCharts() {
    updateTrendCharts();
    updateCategoryCharts();
    updateTransitCharts();
    updateTaxiCharts();
    updateEventCharts();
    updateCorrelationCharts();
    updateWeatherCharts();
}

/**
 * Update trend analysis charts
 */
function updateTrendCharts() {
    // Check if we have daily data
    if (!processedData.calls311.dailyData) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const days = Object.keys(processedData.calls311.dailyData).sort();
    
    // If too many days, sample to avoid overcrowding
    let displayDays = days;
    let displayData = processedData.calls311.dailyData;
    
    if (days.length > 14) {
        // Sample at most 14 days for clarity
        const sampleInterval = Math.max(1, Math.floor(days.length / 14));
        displayDays = days.filter((_, i) => i % sampleInterval === 0);
        
        // Filter data for sampled days
        displayData = {};
        displayDays.forEach(day => {
            displayData[day] = processedData.calls311.dailyData[day];
        });
    }
    
    // Daily trend chart
    const trendDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: displayDays.map(day => displayData[day].byBorough[borough] || 0),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        tension: 0.2
    }));
    
    if (charts.trends) charts.trends.destroy();
    charts.trends = new Chart(
        document.getElementById('trends-chart'),
        {
            type: 'line',
            data: {
                labels: displayDays,
                datasets: trendDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: '311 Calls Over Time',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Calls',
                            font: {
                                size: 10
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45,
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Day of week chart
    const dowLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const dowDatasets = [
        {
            label: '311 Calls',
            data: Array(7).fill(0),
            backgroundColor: DATASET_COLORS.calls311
        }
    ];
    
    // Add transit data if available
    if (processedData.transit.dowByBorough) {
        dowDatasets.push({
            label: 'Transit Entries',
            data: Array(7).fill(0),
            backgroundColor: DATASET_COLORS.transit
        });
    }
    
    // Add taxi data if available
    if (processedData.taxi.dowByBorough) {
        dowDatasets.push({
            label: 'Taxi Pickups',
            data: Array(7).fill(0),
            backgroundColor: DATASET_COLORS.taxi
        });
    }
    
    // Aggregate calls by day of week
    validBoroughs.forEach(borough => {
        if (processedData.calls311.dowByBorough) {
            processedData.calls311.dowByBorough[borough].forEach((count, dow) => {
                dowDatasets[0].data[dow] += count;
            });
        }
        
        // Add transit data if available
        if (processedData.transit.dowByBorough && dowDatasets.length > 1) {
            processedData.transit.dowByBorough[borough].forEach((count, dow) => {
                dowDatasets[1].data[dow] += count * 0.1; // Scale down transit data
            });
        }
        
        // Add taxi data if available
        if (processedData.taxi.dowByBorough && dowDatasets.length > 2) {
            processedData.taxi.dowByBorough[borough].forEach((count, dow) => {
                dowDatasets[2].data[dow] += count;
            });
        }
    });
    
    if (charts.dow) charts.dow.destroy();
    charts.dow = new Chart(
        document.getElementById('dow-chart'),
        {
            type: 'bar',
            data: {
                labels: dowLabels,
                datasets: dowDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Activity by Day of Week',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Activity Count',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Hour of day chart
    const hourLabels = Array(24).fill().map((_, i) => i);
    const hourDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: processedData.calls311.hourlyByBorough[borough],
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.hour) charts.hour.destroy();
    charts.hour = new Chart(
        document.getElementById('hour-chart'),
        {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: hourDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: '311 Calls by Hour of Day',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Calls',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            stepSize: 2,
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                return `${value}:00`;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Borough proportion over time
    const proportionDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: displayDays.map(day => {
            const total = displayData[day].total;
            return total > 0 ? (displayData[day].byBorough[borough] / total) * 100 : 0;
        }),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.proportion) charts.proportion.destroy();
    charts.proportion = new Chart(
        document.getElementById('proportion-chart'),
        {
            type: 'line',
            data: {
                labels: displayDays,
                datasets: proportionDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Borough Proportion Over Time',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Percentage of Daily Calls',
                            font: {
                                size: 10
                            }
                        },
                        min: 0,
                        max: 100,
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45,
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update category charts
 */
function updateCategoryCharts() {
    // Check if we have complaint types data
    if (!processedData.calls311.complaintTypes) return;
    
    // Populate categories list
    const categoriesList = document.getElementById('categories-list');
    categoriesList.innerHTML = '';
    
    // Get sorted complaints
    const sortedComplaints = Object.entries(processedData.calls311.complaintTypes)
        .sort((a, b) => b[1].total - a[1].total);
    
    // Create list items for top 20 complaints
    sortedComplaints.slice(0, 20).forEach(([complaint, data]) => {
        const div = document.createElement('div');
        div.className = 'category-item p-2 border-b flex justify-between items-center';
        
        div.innerHTML = `
            <span class="complaint-name">${complaint}</span>
            <span class="text-gray-700 font-medium">${formatNumber(data.total)}</span>
        `;
        
        div.addEventListener('click', () => {
            // Update selected state
            document.querySelectorAll('.category-item').forEach(el => 
                el.classList.remove('selected')
            );
            div.classList.add('selected');
            
            // Update category chart
            updateCategoryChart(complaint, data);
        });
        
        categoriesList.appendChild(div);
    });
    
    // Select first category by default
    if (sortedComplaints.length > 0) {
        const [firstComplaint, firstData] = sortedComplaints[0];
        document.querySelector('.category-item')?.classList.add('selected');
        updateCategoryChart(firstComplaint, firstData);
    }
}

/**
 * Update category breakdown chart
 * @param {string} complaint - Complaint type
 * @param {Object} data - Complaint data
 */
function updateCategoryChart(complaint, data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    if (charts.categories) charts.categories.destroy();
    charts.categories = new Chart(
        document.getElementById('categories-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: complaint,
                    data: validBoroughs.map(borough => data.byBorough[borough] || 0),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: complaint.length > 40 ? complaint.substring(0, 40) + '...' : complaint,
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Complaints',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update transit charts
 */
function updateTransitCharts() {
    // Check if we have transit data
    if (!processedData.transit.ridershipByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Transit by borough chart
    if (charts.transitBorough) charts.transitBorough.destroy();
    charts.transitBorough = new Chart(
        document.getElementById('transit-borough-chart'),
        {
            type: 'pie',
            data: {
                labels: validBoroughs,
                datasets: [{
                    data: validBoroughs.map(borough => 
                        processedData.transit.ridershipByBorough[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ridership by Borough',
                        font: {
                            size: 14
                        }
                    }
                }
            }
        }
    );
    
    // Transit by time of day chart
    const hourLabels = Array(24).fill().map((_, i) => i);
    const timeDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: processedData.transit.hourlyByBorough?.[borough] || Array(24).fill(0),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.transitTime) charts.transitTime.destroy();
    charts.transitTime = new Chart(
        document.getElementById('transit-time-chart'),
        {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: timeDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ridership by Hour of Day',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Entries',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            stepSize: 2,
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                return `${value}:00`;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Top stations list
    const topStations = document.getElementById('top-stations');
    topStations.innerHTML = '';
    
    // Get sorted stations
    const sortedStations = Object.entries(processedData.transit.stationRidership || {})
        .sort((a, b) => b[1].total - a[1].total);
    
    // Create list items for top stations
    sortedStations.slice(0, 9).forEach(([station, data]) => {
        const div = document.createElement('div');
        div.className = 'p-2 bg-gray-50 rounded-lg text-xs';
        
        div.innerHTML = `
            <div class="font-medium">${station}</div>
            <div class="text-gray-600">${data.borough}</div>
            <div class="font-medium text-green-800 mt-1">${formatNumber(Math.round(data.total))} entries</div>
        `;
        
        topStations.appendChild(div);
    });
}

/**
 * Update taxi charts
 */
function updateTaxiCharts() {
    // Check if we have taxi data
    if (!processedData.taxi.pickupsByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Trip volume by time chart
    const hourLabels = Array(24).fill().map((_, i) => i);
    const timeDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: processedData.taxi.hourlyByBorough?.[borough] || Array(24).fill(0),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.taxiTime) charts.taxiTime.destroy();
    charts.taxiTime = new Chart(
        document.getElementById('taxi-time-chart'),
        {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: timeDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Trip Volume by Hour of Day',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Pickups',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            stepSize: 2,
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                return `${value}:00`;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Average trip distance chart
    if (charts.taxiDistance) charts.taxiDistance.destroy();
    charts.taxiDistance = new Chart(
        document.getElementById('taxi-distance-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: 'Average Trip Distance (miles)',
                    data: validBoroughs.map(borough => 
                        processedData.taxi.metrics?.distanceByBorough?.[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Average Trip Distance by Borough',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Miles',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Popular pickup/dropoff zones chart
    const pickupData = validBoroughs.map(borough => 
        processedData.taxi.pickupsByBorough[borough] || 0
    );
    
    const dropoffData = validBoroughs.map(borough => 
        processedData.taxi.dropoffsByBorough[borough] || 0
    );
    
    if (charts.taxiLocations) charts.taxiLocations.destroy();
    charts.taxiLocations = new Chart(
        document.getElementById('taxi-locations-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [
                    {
                        label: 'Pickups',
                        data: pickupData,
                        backgroundColor: '#F59E0B',
                    },
                    {
                        label: 'Dropoffs',
                        data: dropoffData,
                        backgroundColor: '#60A5FA',
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Pickup vs Dropoff Locations',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Trips',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update event charts
 */
function updateEventCharts() {
    // Check if we have events data
    if (!processedData.events.eventsByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Events by borough chart
    if (charts.eventsBorough) charts.eventsBorough.destroy();
    charts.eventsBorough = new Chart(
        document.getElementById('events-borough-chart'),
        {
            type: 'pie',
            data: {
                labels: validBoroughs,
                datasets: [{
                    data: validBoroughs.map(borough => 
                        processedData.events.eventsByBorough[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Events by Borough',
                        font: {
                            size: 14
                        }
                    }
                }
            }
        }
    );
    
    // Events by type chart
    if (!processedData.events.eventTypes) return;
    
    // Get top event types
    const sortedTypes = Object.entries(processedData.events.eventTypes)
        .sort((a, b) => b[1].total - a[1].total)
        .slice(0, 5);
    
    if (charts.eventsType) charts.eventsType.destroy();
    charts.eventsType = new Chart(
        document.getElementById('events-type-chart'),
        {
            type: 'bar',
            data: {
                labels: sortedTypes.map(([type]) => type),
                datasets: [{
                    label: 'Number of Events',
                    data: sortedTypes.map(([_, data]) => data.total),
                    backgroundColor: sortedTypes.map((_, i) => 
                        `hsl(${270 + (i * 20)}, 70%, 60%)`
                    ),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Top Event Types',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Events',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                const label = this.getLabelForValue(value);
                                return label.length > 15 ? label.substring(0, 15) + '...' : label;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Upcoming/recent events list
    const eventsList = document.getElementById('events-list');
    eventsList.innerHTML = '';
    
    // Get sorted events by date
    const sortedEvents = [...(processedData.events.eventsList || [])]
        .sort((a, b) => new Date(a.start) - new Date(b.start));
    
    // Create list items for events
    sortedEvents.slice(0, 10).forEach(event => {
        const div = document.createElement('div');
        div.className = 'p-2 border-b';
        
        const startDate = new Date(event.start);
        const formattedDate = startDate.toLocaleDateString();
        
        div.innerHTML = `
            <div class="font-medium text-sm">${event.name}</div>
            <div class="text-xs flex justify-between mt-1">
                <span>${formattedDate}</span>
                <span class="font-medium">${event.borough}</span>
            </div>
        `;
        
        eventsList.appendChild(div);
    });
}

/**
 * Update correlation charts
 */
function updateCorrelationCharts() {
    // Calculate correlations
    const correlations = calculateDatasetCorrelations();
    
    // Transit vs 311 correlation chart
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    if (charts.transit311) charts.transit311.destroy();
    charts.transit311 = new Chart(
        document.getElementById('transit-311-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: 'Correlation Coefficient',
                    data: validBoroughs.map(borough => 
                        correlations.transitVs311[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => {
                        const corr = correlations.transitVs311[borough] || 0;
                        return corr >= 0 ? '#10B981' : '#EF4444';
                    }),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Transit & 311 Call Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Taxi vs 311 correlation chart
    if (charts.taxi311) charts.taxi311.destroy();
    charts.taxi311 = new Chart(
        document.getElementById('taxi-311-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: 'Correlation Coefficient',
                    data: validBoroughs.map(borough => 
                        correlations.taxiVs311[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => {
                        const corr = correlations.taxiVs311[borough] || 0;
                        return corr >= 0 ? '#F59E0B' : '#EF4444';
                    }),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Taxi & 311 Call Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Events impact chart
    if (correlations.eventsImpact && correlations.eventsImpact.length > 0) {
        const impactEvents = correlations.eventsImpact.slice(0, 5);
        
        if (charts.eventsImpact) charts.eventsImpact.destroy();
        charts.eventsImpact = new Chart(
            document.getElementById('events-impact-chart'),
            {
                type: 'bar',
                data: {
                    labels: impactEvents.map(event => event.event.length > 15 ? 
                        event.event.substring(0, 15) + '...' : event.event
                    ),
                    datasets: [{
                        label: 'Percent Change in 311 Calls',
                        data: impactEvents.map(event => event.percentChange),
                        backgroundColor: impactEvents.map(event => 
                            event.percentChange >= 0 ? '#8B5CF6' : '#EF4444'
                        ),
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Events Impact on 311 Calls',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return `Change: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Percent Change',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        },
                        y: {
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Correlation matrix
    const datasets = ['calls311', 'transit', 'taxi', 'events'];
    const matrix = [];
    
    // Calculate all pair-wise correlations
    for (let i = 0; i < datasets.length; i++) {
        matrix.push([]);
        
        for (let j = 0; j < datasets.length; j++) {
            if (i === j) {
                // Perfect correlation with self
                matrix[i].push(1);
            } else {
                // Calculate average borough correlation
                let sum = 0, count = 0;
                
                validBoroughs.forEach(borough => {
                    if (datasets[i] === 'calls311' && datasets[j] === 'transit') {
                        if (correlations.transitVs311 && correlations.transitVs311[borough] !== undefined) {
                            sum += correlations.transitVs311[borough];
                            count++;
                        }
                    } else if (datasets[i] === 'transit' && datasets[j] === 'calls311') {
                        if (correlations.transitVs311 && correlations.transitVs311[borough] !== undefined) {
                            sum += correlations.transitVs311[borough];
                            count++;
                        }
                    } else if (datasets[i] === 'calls311' && datasets[j] === 'taxi') {
                        if (correlations.taxiVs311 && correlations.taxiVs311[borough] !== undefined) {
                            sum += correlations.taxiVs311[borough];
                            count++;
                        }
                    } else if (datasets[i] === 'taxi' && datasets[j] === 'calls311') {
                        if (correlations.taxiVs311 && correlations.taxiVs311[borough] !== undefined) {
                            sum += correlations.taxiVs311[borough];
                            count++;
                        }
                    } else {
                        // For other combinations, use a default low correlation
                        sum += 0.1;
                        count++;
                    }
                });
                
                matrix[i].push(count > 0 ? sum / count : 0);
            }
        }
    }
    
    if (charts.correlationMatrix) charts.correlationMatrix.destroy();   
    charts.correlationMatrix = new Chart(
        document.getElementById('correlation-matrix'),
        {
            type: 'heatmap',
            data: {
                labels: ['311 Calls', 'Transit', 'Taxi', 'Events'],
                datasets: [{
                    label: 'Correlation',
                    data: matrix.flat(),
                    width: 4,
                    height: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Dataset Correlation Matrix',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',
                        labels: ['311 Calls', 'Transit', 'Taxi', 'Events'],
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    y: {
                        type: 'category',
                        labels: ['311 Calls', 'Transit', 'Taxi', 'Events'],
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update weather correlation charts
 */
function updateWeatherCharts() {
    // Check if we have weather data
    if (Object.keys(processedData.weather).length === 0) {
        document.getElementById('weather-findings').innerHTML = 
            '<p class="text-center p-4">Weather data not available. Please update dashboard first.</p>';
        
        // Clear charts if they exist
        if (charts.temp) {
            charts.temp.destroy();
            charts.temp = null;
        }
        if (charts.precip) {
            charts.precip.destroy();
            charts.precip = null;
        }
        return;
    }
    
    // Prepare temp vs call data
    const tempData = [];
    const precipData = [];
    
    Object.entries(processedData.weather).forEach(([date, data]) => {
        if (data.tmax !== null && processedData.calls311.dailyData && processedData.calls311.dailyData[date]) {
            tempData.push({
                x: data.tmax,
                y: processedData.calls311.dailyData[date].total,
                date: date
            });
        }
        
        if (data.prcp !== null && processedData.calls311.dailyData && processedData.calls311.dailyData[date]) {
            precipData.push({
                x: data.prcp,
                y: processedData.calls311.dailyData[date].total,
                date: date
            });
        }
    });
    
    // Temperature correlation chart
    if (charts.temp) charts.temp.destroy();
    
    if (tempData.length === 0) {
        // Handle empty temperature data
        document.getElementById('temp-correlation').getContext('2d').clearRect(
            0, 0, 
            document.getElementById('temp-correlation').width, 
            document.getElementById('temp-correlation').height
        );
    } else {
        charts.temp = new Chart(
            document.getElementById('temp-correlation'),
            {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Daily Calls vs Max Temp',
                        data: tempData,
                        backgroundColor: '#3B82F6',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Temperature vs. 311 Call Volume',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return `Date: ${point.date}, Temp: ${point.x}°F, Calls: ${point.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of 311 Calls',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Maximum Temperature (°F)',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Precipitation correlation chart
    if (charts.precip) charts.precip.destroy();
    
    if (precipData.length === 0) {
        // Handle empty precipitation data
        document.getElementById('precip-correlation').getContext('2d').clearRect(
            0, 0, 
            document.getElementById('precip-correlation').width, 
            document.getElementById('precip-correlation').height
        );
    } else {
        charts.precip = new Chart(
            document.getElementById('precip-correlation'),
            {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Daily Calls vs Precipitation',
                        data: precipData,
                        backgroundColor: '#10B981',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Precipitation vs. 311 Call Volume',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return `Date: ${point.date}, Precip: ${point.x} in, Calls: ${point.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of 311 Calls',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Precipitation (inches)',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Weather findings analysis
    updateWeatherFindings();
}

/**
 * Update weather findings analysis
 */
function updateWeatherFindings() {
    const weatherFindings = document.getElementById('weather-findings');
    
    // Analyze weather-sensitive complaints
    if (!processedData.calls311.complaintTypes || Object.keys(processedData.weather).length === 0) {
        weatherFindings.innerHTML = '<p class="text-center p-4">Insufficient data to determine weather correlations.</p>';
        return;
    }
    
    // Group complaints by temperature ranges
    const tempRanges = [
        { name: 'Cold', min: -20, max: 40 },
        { name: 'Cool', min: 40, max: 60 },
        { name: 'Mild', min: 60, max: 75 },
        { name: 'Warm', min: 75, max: 85 },
        { name: 'Hot', min: 85, max: 110 }
    ];
    
    const complaintsTemp = {};
    const complaintsPrec = { 'Rainy': {}, 'Dry': {} };
    
    // Analyze by temperature
    Object.entries(processedData.weather).forEach(([date, weather]) => {
        if (!processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
        
        // Process by temperature
        if (weather.tmax !== null) {
            const range = tempRanges.find(r => weather.tmax >= r.min && weather.tmax < r.max);
            if (!range) return;
            
            // Get complaints for this day
            const complaints = {};
            
            // Filter 311 data for this date
            all311Data.forEach(call => {
                if (call.parsed_date === date) {
                    if (!complaints[call.complaint]) complaints[call.complaint] = 0;
                    complaints[call.complaint]++;
                }
            });
            
            // Aggregate by temperature range
            Object.entries(complaints).forEach(([complaint, count]) => {
                if (!complaintsTemp[complaint]) {
                    complaintsTemp[complaint] = tempRanges.reduce((acc, r) => {
                        acc[r.name] = { count: 0, days: 0 };
                        return acc;
                    }, {});
                }
                
                complaintsTemp[complaint][range.name].count += count;
                complaintsTemp[complaint][range.name].days += 1;
            });
        }
        
        // Process by precipitation
        if (weather.prcp !== null) {
            const isRainy = weather.prcp > 0.1;
            const category = isRainy ? 'Rainy' : 'Dry';
            
            // Filter 311 data for this date
            all311Data.forEach(call => {
                if (call.parsed_date === date) {
                    if (!complaintsPrec[category][call.complaint]) {
                        complaintsPrec[category][call.complaint] = 0;
                    }
                    complaintsPrec[category][call.complaint]++;
                }
            });
        }
    });
    
    // Find temperature-sensitive complaints
    const tempSensitive = Object.entries(complaintsTemp)
        .map(([complaint, ranges]) => {
            // Calculate frequencies
            const frequencies = Object.entries(ranges).map(([range, data]) => {
                return { range, freq: data.days > 0 ? data.count / data.days : 0 };
            });
            
            // Find min and max frequency
            const freqValues = frequencies.map(f => f.freq);
            const minFreq = Math.min(...freqValues);
            const maxFreq = Math.max(...freqValues);
            
            // Calculate spread
            const spread = minFreq > 0 ? maxFreq / minFreq : 0;
            
            return {
                complaint,
                spread,
                frequencies
            };
        })
        .filter(c => c.spread > 1.5 && c.frequencies.some(f => f.freq > 5))
        .sort((a, b) => b.spread - a.spread)
        .slice(0, 5);
    
    // Find precipitation-sensitive complaints
    const precipSensitive = [];
    
    Object.keys(complaintsPrec.Rainy).forEach(complaint => {
        if (complaintsPrec.Dry[complaint]) {
            const rainyCount = complaintsPrec.Rainy[complaint];
            const dryCount = complaintsPrec.Dry[complaint];
            
            // Count rainy and dry days
            const rainyDays = Object.values(processedData.weather)
                .filter(data => data.prcp !== null && data.prcp > 0.1)
                .length;
                
            const dryDays = Object.values(processedData.weather)
                .filter(data => data.prcp !== null && data.prcp <= 0.1)
                .length;
            
            // Calculate rates
            const rainyRate = rainyDays > 0 ? rainyCount / rainyDays : 0;
            const dryRate = dryDays > 0 ? dryCount / dryDays : 0;
            
            // Calculate ratio
            const ratio = Math.max(rainyRate, dryRate) / Math.max(0.1, Math.min(rainyRate, dryRate));
            const diff = Math.abs(rainyRate - dryRate);
            
            if (ratio > 1.3 && diff > 1) {
                precipSensitive.push({
                    complaint,
                    rainyRate,
                    dryRate,
                    ratio,
                    more: rainyRate > dryRate ? 'rainy' : 'dry'
                });
            }
        }
    });
    
    // Sort by ratio
    precipSensitive.sort((a, b) => b.ratio - a.ratio);
    
    // Create HTML output
    let html = '<div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-xs">';
    
    // Temperature findings
    html += '<div>';
    html += '<h4 class="font-medium mb-1">Temperature-Sensitive Complaints:</h4>';
    if (tempSensitive.length === 0) {
        html += '<p>Insufficient data to determine temperature correlation.</p>';
    } else {
        html += '<ul class="list-disc pl-4">';
        tempSensitive.forEach(item => {
            const maxFreq = Math.max(...item.frequencies.map(f => f.freq));
            const maxRange = item.frequencies.find(f => f.freq === maxFreq).range;
            
            html += `<li><span class="font-medium">${item.complaint}</span>: ${Math.round(item.spread * 10) / 10}x more frequent during <span class="font-medium">${maxRange}</span> weather</li>`;
        });
        html += '</ul>';
    }
    html += '</div>';
    
    // Precipitation findings
    html += '<div>';
    html += '<h4 class="font-medium mb-1">Precipitation-Sensitive Complaints:</h4>';
    if (precipSensitive.length === 0) {
        html += '<p>Insufficient data to determine precipitation correlation.</p>';
    } else {
        html += '<ul class="list-disc pl-4">';
        precipSensitive.slice(0, 5).forEach(item => {
            html += `<li><span class="font-medium">${item.complaint}</span>: ${Math.round(item.ratio * 10) / 10}x more frequent during <span class="font-medium">${item.more}</span> days</li>`;
        });
        html += '</ul>';
    }
    html += '</div>';
    
    html += '</div>';
    
    weatherFindings.innerHTML = html;
}

================================================================================

FILE: collector.py
LINES: 129
--------------------------------------------------------------------------------

#!/usr/bin/env python3
"""
File Collector Script

This script recursively searches through directories starting from the current directory,
finds all files (excluding specified binary/media formats), and collects their content into 
a single text file with file paths and separators for better readability.
"""

import os
import argparse
from datetime import datetime


def collect_code(root_dir='.', output_file='code_collection.txt', exclude_extensions=None, ignore_dirs=None):
    """
    Recursively collect all files into a single text file.
    
    Args:
        root_dir (str): Root directory to start the search from
        output_file (str): Name of the output file
        exclude_extensions (list): List of file extensions to exclude (e.g., ['.pyc', '.exe'])
        ignore_dirs (list): List of directory names to ignore (e.g., ['node_modules', '.git'])
    """
    if exclude_extensions is None:
        # Default extensions to exclude - typically binary or temporary files
        exclude_extensions = [
            '.pyc', '.pyo', '.pyd', '.exe', '.dll', '.so', '.o', '.obj',
            '.class', '.jar', '.war', '.ear', '.zip', '.tar', '.gz', '.7z',
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg', '.mp3',
            '.mp4', '.avi', '.mov', '.flv', '.wmv', '.pdf', '.doc', '.docx',
            '.xls', '.xlsx', '.ppt', '.pptx'
        ]
    
    if ignore_dirs is None:
        # Default directories to ignore - add or remove based on your needs
        ignore_dirs = ['.git', 'node_modules', 'venv', '__pycache__', 'dist', 'build']
    
    # Convert exclude_extensions to lowercase for case-insensitive matching
    exclude_extensions = [ext.lower() for ext in exclude_extensions]
    
    # Get absolute path of root directory
    root_dir = os.path.abspath(root_dir)
    
    print(f"Starting code collection from {root_dir}")
    print(f"Excluding extensions: {', '.join(exclude_extensions)}")
    print(f"Ignoring directories: {', '.join(ignore_dirs)}")
    
    # Total counters
    total_files = 0
    total_lines = 0
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Write header
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        outfile.write(f"CODE COLLECTION GENERATED ON {timestamp}\n")
        outfile.write(f"Root directory: {root_dir}\n")
        outfile.write("=" * 80 + "\n\n")
        
        # Walk through directory tree
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Remove ignored directories from dirnames to prevent walking into them
            # Using slice assignment to modify dirnames in-place (required by os.walk)
            dirnames[:] = [d for d in dirnames if d not in ignore_dirs]
            
            for filename in filenames:
                # Check if the file does not have one of the excluded extensions
                file_ext = os.path.splitext(filename)[1].lower()
                if file_ext not in exclude_extensions:
                    file_path = os.path.join(dirpath, filename)
                    rel_path = os.path.relpath(file_path, root_dir)
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                            
                            # Count lines
                            line_count = content.count('\n') + (0 if content.endswith('\n') else 1)
                            total_lines += line_count
                            total_files += 1
                            
                            # Write file info and content to output file
                            outfile.write(f"FILE: {rel_path}\n")
                            outfile.write(f"LINES: {line_count}\n")
                            outfile.write("-" * 80 + "\n\n")
                            outfile.write(content)
                            outfile.write("\n\n")
                            outfile.write("=" * 80 + "\n\n")
                            
                            print(f"Added: {rel_path} ({line_count} lines)")
                    except Exception as e:
                        print(f"Error reading {rel_path}: {e}")
    
    # Write summary at the end of the file
    with open(output_file, 'a', encoding='utf-8') as outfile:
        outfile.write(f"\nSUMMARY\n")
        outfile.write(f"Total files processed: {total_files}\n")
        outfile.write(f"Total lines of code: {total_lines}\n")
    
    print(f"\nCollection complete!")
    print(f"Processed {total_files} files with {total_lines} lines of code")
    print(f"Output saved to: {os.path.abspath(output_file)}")


def main():
    """Parse command line arguments and run the script."""
    parser = argparse.ArgumentParser(description='Collect all files into a single text file.')
    parser.add_argument('-d', '--directory', default='.', help='Root directory to start from (default: current directory)')
    parser.add_argument('-o', '--output', default='file_collection.txt', help='Output file name (default: file_collection.txt)')
    parser.add_argument('-e', '--exclude', nargs='+', help='File extensions to exclude (e.g., .exe .jpg)')
    parser.add_argument('-i', '--ignore', nargs='+', help='Directories to ignore (e.g., node_modules .git)')
    
    args = parser.parse_args()
    
    # Convert exclude extensions from command line to proper format with leading dot
    exclude_extensions = None
    if args.exclude:
        exclude_extensions = [ext if ext.startswith('.') else f'.{ext}' for ext in args.exclude]
    
    collect_code(
        root_dir=args.directory,
        output_file=args.output,
        exclude_extensions=exclude_extensions,
        ignore_dirs=args.ignore
    )


if __name__ == "__main__":
    main()

================================================================================

FILE: config.js
LINES: 140
--------------------------------------------------------------------------------

// Configuration settings for NYC Urban Rhythm

// Mapbox access token
const MAPBOX_ACCESS_TOKEN = 'pk.eyJ1IjoicHJhdGhhbXNhcmFmMDA3IiwiYSI6ImNtOXljeWExajFlOTYyanBzdmh2YXplNXMifQ.UCm1kg1UeqCrz0j16fpQtA';

// NYC Borough configurations
const BOROUGH_CENTROIDS = {
    Manhattan: [40.7831, -73.9712],
    Brooklyn: [40.6782, -73.9442],
    Bronx: [40.8448, -73.8648],
    Queens: [40.7282, -73.7949],
    'Staten Island': [40.5795, -74.1502]
};

// Color schemes for boroughs
const BOROUGH_COLORS = {
    Manhattan: '#3182CE',
    Brooklyn: '#F59E0B',
    Bronx: '#10B981',
    Queens: '#6366F1', 
    'Staten Island': '#EC4899'
};

// Weather station mapping
const WEATHER_STATIONS = {
    Manhattan: 'USW00094728',
    Brooklyn: 'USW00094777',
    Bronx: 'USW00014727',
    Queens: 'USW00014734',
    'Staten Island': 'USW00014736'
};

// Dataset color coding
const DATASET_COLORS = {
    calls311: '#3B82F6',
    transit: '#10B981',
    taxi: '#F59E0B',
    events: '#8B5CF6',
    weather: '#A855F7'
};

// NYC Geojson source
const GEOJSON_URL = 'https://raw.githubusercontent.com/codeforgermany/click_that_hood/main/public/data/new-york-city-boroughs.geojson';

// API endpoints
const API_CONFIG = {
    weatherProxy: 'http://localhost:3000/noaa',
    geocodingEndpoint: 'https://api.mapbox.com/geocoding/v5/mapbox.places/'
};

// Default temporal aggregation settings
const TIME_AGGREGATION = {
    hourly: {
        format: 'HH:mm',
        labelFormat: 'ha',
        buckets: 24
    },
    daily: {
        format: 'YYYY-MM-DD',
        labelFormat: 'MMM D',
        buckets: 31
    },
    weekly: {
        format: 'YYYY-[W]WW',
        labelFormat: 'MMM D',
        buckets: 52
    },
    monthly: {
        format: 'YYYY-MM',
        labelFormat: 'MMM YYYY',
        buckets: 12
    }
};

// Chart configuration defaults
const CHART_DEFAULTS = {
    responsive: true,
    maintainAspectRatio: false,
    animation: {
        duration: 1000
    },
    scales: {
        y: {
            beginAtZero: true,
            ticks: {
                font: { size: 10 }
            }
        },
        x: {
            ticks: {
                font: { size: 10 }
            }
        }
    },
    plugins: {
        legend: {
            position: 'top',
            labels: {
                boxWidth: 12,
                font: { size: 10 }
            }
        },
        tooltip: {
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            titleColor: '#333',
            bodyColor: '#333',
            borderColor: '#ddd',
            borderWidth: 1,
            padding: 10,
            displayColors: true,
            titleFont: { size: 12, weight: 'bold' },
            bodyFont: { size: 11 }
        }
    }
};

// Zone ID to borough mapping for TLC data
const ZONE_TO_BOROUGH = {
    // Manhattan (1-143)
    1: 'Manhattan', 2: 'Manhattan', 3: 'Manhattan', 4: 'Manhattan', 5: 'Manhattan',
    6: 'Manhattan', 7: 'Manhattan', 8: 'Manhattan', 9: 'Manhattan', 10: 'Manhattan',
    11: 'Manhattan', 12: 'Manhattan', 13: 'Manhattan', 14: 'Manhattan', 15: 'Manhattan',
    // ... add more as needed for your dataset
    
    // Bronx (144-200)
    144: 'Bronx', 145: 'Bronx', 146: 'Bronx', 147: 'Bronx', 148: 'Bronx',
    // ... add more as needed
    
    // Brooklyn (201-263)
    201: 'Brooklyn', 202: 'Brooklyn', 203: 'Brooklyn', 204: 'Brooklyn', 205: 'Brooklyn',
    // ... add more as needed
    
    // Queens (264-324)
    264: 'Queens', 265: 'Queens', 266: 'Queens', 267: 'Queens', 268: 'Queens',
    // ... add more as needed
    
    // Staten Island (325-344)
    325: 'Staten Island', 326: 'Staten Island', 327: 'Staten Island', 328: 'Staten Island',
    // ... add more as needed
};

================================================================================

FILE: correlationDashboard.js
LINES: 704
--------------------------------------------------------------------------------

/**
 * Cross-dataset correlation analysis and dashboard for NYC Urban Rhythm
 */

/**
 * Calculate correlations between all datasets
 * @param {Object} processedData - Processed data from all datasets
 * @returns {Object} - Correlation matrix and insights
 */
function calculateAllCorrelations() {
    // Initialize correlation object
    const correlations = {
        matrix: {},
        insights: [],
        hotspots: []
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Datasets to analyze
    const datasets = ['calls311', 'transit', 'taxi', 'events'];
    
    // Initialize correlation matrix
    datasets.forEach(d1 => {
        correlations.matrix[d1] = {};
        datasets.forEach(d2 => {
            correlations.matrix[d1][d2] = d1 === d2 ? 1 : null;
        });
    });
    
    // Calculate correlations between datasets
    
    // 1. Transit vs 311
    const transit311 = calculateTransit311Correlation();
    if (transit311) {
        // Set matrix values
        correlations.matrix['transit']['calls311'] = 
        correlations.matrix['calls311']['transit'] = 
            Object.values(transit311.byBorough).reduce((sum, val) => sum + val, 0) / 
            Object.values(transit311.byBorough).length;
        
        // Add borough-level insights
        validBoroughs.forEach(borough => {
            if (transit311.byBorough[borough] !== undefined) {
                const corr = transit311.byBorough[borough];
                if (Math.abs(corr) > 0.5) {
                    correlations.insights.push({
                        type: 'transit-311',
                        borough,
                        correlation: corr,
                        description: `${borough} shows a ${corr > 0 ? 'positive' : 'negative'} correlation (${corr.toFixed(2)}) between transit ridership and 311 calls`
                    });
                }
            }
        });
    }
    
    // 2. Taxi vs 311
    const taxi311 = analyzeTaxi311Correlation();
    if (taxi311) {
        // Set matrix values
        correlations.matrix['taxi']['calls311'] = 
        correlations.matrix['calls311']['taxi'] = 
            Object.values(taxi311.byBorough).reduce((sum, val) => sum + val, 0) / 
            Object.values(taxi311.byBorough).length;
        
        // Add borough-level insights
        validBoroughs.forEach(borough => {
            if (taxi311.byBorough[borough] !== undefined) {
                const corr = taxi311.byBorough[borough];
                if (Math.abs(corr) > 0.5) {
                    correlations.insights.push({
                        type: 'taxi-311',
                        borough,
                        correlation: corr,
                        description: `${borough} shows a ${corr > 0 ? 'positive' : 'negative'} correlation (${corr.toFixed(2)}) between taxi activity and 311 calls`
                    });
                }
            }
        });
    }
    
    // 3. Events impact on other datasets
    if (processedData.events.eventsList && processedData.events.eventsList.length > 0) {
        // Analyze event impact
        const eventAnalysis = analyzeEventImpact(
            processedData.events.eventsList,
            document.getElementById('startDate').value,
            document.getElementById('endDate').value
        );
        
        if (eventAnalysis.impact && eventAnalysis.impact.length > 0) {
            // Calculate average impact
            const avgImpact = eventAnalysis.impact.reduce((sum, event) => {
                return sum + Math.abs(event.percentChange || 0);
            }, 0) / eventAnalysis.impact.length;
            
            // Set matrix value based on impact magnitude
            correlations.matrix['events']['calls311'] = 
            correlations.matrix['calls311']['events'] = 
                avgImpact > 50 ? 0.8 : avgImpact > 30 ? 0.6 : avgImpact > 15 ? 0.4 : 0.2;
            
            // Add insights for significant impacts
            eventAnalysis.impact.slice(0, 3).forEach(impact => {
                if (Math.abs(impact.percentChange || 0) > 20) {
                    correlations.insights.push({
                        type: 'event-impact',
                        event: impact.event,
                        borough: impact.borough,
                        change: impact.percentChange,
                        description: `Event "${impact.event}" in ${impact.borough} caused a ${impact.percentChange.toFixed(1)}% change in 311 calls`
                    });
                }
            });
        }
    }
    
    // 4. Transit vs Taxi
    // Use hourly patterns to calculate correlation
    if (processedData.transit.hourlyByBorough && processedData.taxi.hourlyByBorough) {
        const transitHourly = Array(24).fill(0);
        const taxiHourly = Array(24).fill(0);
        
        validBoroughs.forEach(borough => {
            for (let hour = 0; hour < 24; hour++) {
                transitHourly[hour] += processedData.transit.hourlyByBorough[borough][hour] || 0;
                taxiHourly[hour] += processedData.taxi.hourlyByBorough[borough][hour] || 0;
            }
        });
        
        // Calculate correlation
        const transitTaxiCorr = calculateCorrelation(transitHourly, taxiHourly);
        
        // Set matrix values
        correlations.matrix['transit']['taxi'] = 
        correlations.matrix['taxi']['transit'] = transitTaxiCorr;
        
        if (Math.abs(transitTaxiCorr) > 0.5) {
            correlations.insights.push({
                type: 'transit-taxi',
                correlation: transitTaxiCorr,
                description: `Transit and taxi activity show a ${transitTaxiCorr > 0 ? 'positive' : 'negative'} correlation (${transitTaxiCorr.toFixed(2)}) throughout the day`
            });
        }
    }
    
    // 5. Transit/Taxi vs Events
    // Use simple heuristic based on event density
    if (processedData.events.eventsList && processedData.events.eventsList.length > 0) {
        // Check event impact on transit
        const eventTransitCorr = 0.3; // Placeholder value based on domain knowledge
        correlations.matrix['events']['transit'] = 
        correlations.matrix['transit']['events'] = eventTransitCorr;
        
        // Check event impact on taxi
        const eventTaxiCorr = 0.4; // Placeholder value based on domain knowledge
        correlations.matrix['events']['taxi'] = 
        correlations.matrix['taxi']['events'] = eventTaxiCorr;
    }
    
    // 6. Weather correlation
    if (Object.keys(processedData.weather).length > 0) {
        // Add weather as a dataset
        correlations.matrix['weather'] = {};
        datasets.forEach(d => {
            correlations.matrix['weather'][d] = null;
            correlations.matrix[d]['weather'] = null;
        });
        correlations.matrix['weather']['weather'] = 1;
        
        // Analyze weather correlation with 311
        const weatherFindings = document.getElementById('weather-findings').innerHTML;
        if (weatherFindings && !weatherFindings.includes('Insufficient data')) {
            correlations.matrix['weather']['calls311'] = 
            correlations.matrix['calls311']['weather'] = 0.4; // Placeholder value based on findings
            
            correlations.insights.push({
                type: 'weather-311',
                description: 'Weather conditions show significant correlation with specific 311 complaint types'
            });
        }
    }
    
    // Find activity hotspots
    const hotspots = findActivityHotspots();
    if (hotspots && hotspots.length > 0) {
        correlations.hotspots = hotspots;
    }
    
    return correlations;
}

/**
 * Find locations with high activity across multiple datasets
 * @returns {Array} - Array of hotspot locations
 */
function findActivityHotspots() {
    const hotspots = [];
    
    // Detect clusters
    const clusters = detectActivityClusters();
    
    // Convert to hotspots
    clusters.forEach(cluster => {
        hotspots.push({
            lat: cluster.center.lat,
            lng: cluster.center.lng,
            pointCount: cluster.pointCount,
            dominantType: cluster.dominant,
            types: cluster.types,
            score: cluster.pointCount
        });
    });
    
    // Sort by score
    hotspots.sort((a, b) => b.score - a.score);
    
    return hotspots.slice(0, 5);
}

/**
 * Calculate urban rhythm patterns
 * @returns {Object} - Rhythm patterns by borough and time
 */
function calculateUrbanRhythms() {
    return calculateRhythmScores();
}

/**
 * Create correlation heatmap for matrix visualization
 * @param {Object} correlationMatrix - Dataset correlation matrix
 * @returns {Array} - Data for heatmap chart
 */
function createCorrelationHeatmap(correlationMatrix) {
    const datasets = Object.keys(correlationMatrix);
    const data = [];
    
    // Convert matrix to heatmap data format
    datasets.forEach((row, i) => {
        datasets.forEach((col, j) => {
            data.push({
                x: col,
                y: row,
                v: correlationMatrix[row][col] || 0
            });
        });
    });
    
    return data;
}

/**
 * Generate urban rhythm visualization
 * @param {Object} rhythms - Urban rhythm data
 * @returns {Object} - Visualization data
 */
function generateRhythmVisualization(rhythms) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Generate hour labels
    const hourLabels = Array(24).fill().map((_, i) => `${i}:00`);
    
    // Generate day labels
    const dowLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    // Initialize visualization object
    const visualization = {
        hourly: {},
        dow: {},
        peaks: {},
        pulseData: []
    };
    
    // Process each borough
    validBoroughs.forEach(borough => {
        // Add hourly data
        visualization.hourly[borough] = rhythms[borough]?.hourly || Array(24).fill(0);
        
        // Add dow data
        visualization.dow[borough] = rhythms[borough]?.dow || Array(7).fill(0);
        
        // Add peak info
        visualization.peaks[borough] = {
            hour: rhythms[borough]?.peakHour || 0,
            day: rhythms[borough]?.peakDay || 0,
            hourLabel: hourLabels[rhythms[borough]?.peakHour || 0],
            dayLabel: dowLabels[rhythms[borough]?.peakDay || 0]
        };
        
        // Create pulse animation data
        const [lat, lng] = BOROUGH_CENTROIDS[borough];
        const activityLevel = rhythms[borough]?.overallActivity || 0;
        
        if (activityLevel > 0) {
            visualization.pulseData.push({
                lat,
                lng,
                radius: Math.min(500 + (activityLevel / 1000), 2000),
                intensity: Math.min(activityLevel / 5000, 1),
                borough,
                peakHour: visualization.peaks[borough].hourLabel,
                peakDay: visualization.peaks[borough].dayLabel,
                color: BOROUGH_COLORS[borough]
            });
        }
    });
    
    return visualization;
}

/**
 * Update correlation dashboard visualizations
 * @param {Object} correlations - Correlation analysis results
 */
function updateCorrelationDashboard(correlations) {
    // Update correlation matrix chart
    updateCorrelationMatrix(correlations.matrix);
    
    // Update transit-311 correlation chart
    updateTransit311Chart();
    
    // Update taxi-311 correlation chart
    updateTaxi311Chart();
    
    // Update events impact chart
    updateEventsImpactChart();
    
    // Add activity pulses to map
    const rhythms = calculateUrbanRhythms();
    const rhythmViz = generateRhythmVisualization(rhythms);
    
    // Add pulses for each borough
    rhythmViz.pulseData.forEach(pulse => {
        createPulseEffect(map, [pulse.lng, pulse.lat], pulse.color);
    });
}

/**
 * Update correlation matrix chart
 * @param {Object} matrix - Correlation matrix
 */
function updateCorrelationMatrix(matrix) {
    // Convert matrix to heatmap data
    const heatmapData = createCorrelationHeatmap(matrix);
    
    // Get datasets
    const datasets = Object.keys(matrix);
    
    // Create heatmap chart
    if (charts.correlationMatrix) charts.correlationMatrix.destroy();
    
    const ctx = document.getElementById('correlation-matrix').getContext('2d');
    
    // Create heatmap manually since Chart.js lacks built-in heatmap
    const cellSize = Math.min(20, ctx.canvas.width / datasets.length);
    const margin = { top: 30, right: 20, bottom: 30, left: 60 };
    const width = cellSize * datasets.length;
    const height = cellSize * datasets.length;
    
    // Clear canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Draw title
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#333';
    ctx.fillText('Dataset Correlation Matrix', ctx.canvas.width / 2, 15);
    
    // Draw x-axis labels
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    datasets.forEach((dataset, i) => {
        const x = margin.left + i * cellSize + cellSize / 2;
        ctx.fillText(dataset, x, margin.top - 10);
    });
    
    // Draw y-axis labels
    ctx.textAlign = 'right';
    datasets.forEach((dataset, i) => {
        const y = margin.top + i * cellSize + cellSize / 2;
        ctx.fillText(dataset, margin.left - 5, y + 3);
    });
    
    // Draw heatmap cells
    heatmapData.forEach(cell => {
        const i = datasets.indexOf(cell.x);
        const j = datasets.indexOf(cell.y);
        const x = margin.left + i * cellSize;
        const y = margin.top + j * cellSize;
        
        // Calculate color based on correlation value
        const value = cell.v === null ? 0 : cell.v;
        let color;
        if (value > 0) {
            const intensity = Math.min(value, 1);
            color = `rgba(21, 128, 61, ${intensity})`;
        } else if (value < 0) {
            const intensity = Math.min(Math.abs(value), 1);
            color = `rgba(220, 38, 38, ${intensity})`;
        } else {
            color = 'rgba(229, 231, 235, 0.5)';
        }
        
        // Draw cell
        ctx.fillStyle = color;
        ctx.fillRect(x, y, cellSize, cellSize);
        
        // Draw cell border
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(x, y, cellSize, cellSize);
        
        // Draw correlation value
        if (value !== 0) {
            ctx.fillStyle = Math.abs(value) > 0.5 ? '#fff' : '#333';
            ctx.textAlign = 'center';
            ctx.font = '9px Arial';
            ctx.fillText(value.toFixed(2), x + cellSize / 2, y + cellSize / 2 + 3);
        }
    });
}

/**
 * Update transit-311 correlation chart
 */
function updateTransit311Chart() {
    // Get correlation data
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const correlations = processedData.correlations?.transitVs311 || {};
    
    // Create chart data
    const data = validBoroughs.map(borough => ({
        borough,
        correlation: correlations[borough] || 0
    }));
    
    // Sort by correlation strength
    data.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
    
    // Create chart
    if (charts.transit311) charts.transit311.destroy();
    charts.transit311 = new Chart(
        document.getElementById('transit-311-chart'),
        {
            type: 'bar',
            data: {
                labels: data.map(d => d.borough),
                datasets: [{
                    label: 'Correlation',
                    data: data.map(d => d.correlation),
                    backgroundColor: data.map(d => 
                        d.correlation >= 0 ? '#10B981' : '#EF4444'
                    )
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Transit & 311 Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update taxi-311 correlation chart
 */
function updateTaxi311Chart() {
    // Get correlation data
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const correlations = processedData.correlations?.taxiVs311 || {};
    
    // Create chart data
    const data = validBoroughs.map(borough => ({
        borough,
        correlation: correlations[borough] || 0
    }));
    
    // Sort by correlation strength
    data.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
    
    // Create chart
    if (charts.taxi311) charts.taxi311.destroy();
    charts.taxi311 = new Chart(
        document.getElementById('taxi-311-chart'),
        {
            type: 'bar',
            data: {
                labels: data.map(d => d.borough),
                datasets: [{
                    label: 'Correlation',
                    data: data.map(d => d.correlation),
                    backgroundColor: data.map(d => 
                        d.correlation >= 0 ? '#F59E0B' : '#EF4444'
                    )
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Taxi & 311 Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update events impact chart
 */
function updateEventsImpactChart() {
    // Check if we have event impact data
    if (!processedData.events.eventsList || processedData.events.eventsList.length === 0) {
        return;
    }
    
    // Analyze event impact
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    const eventAnalysis = analyzeEventImpact(
        processedData.events.eventsList,
        startDate,
        endDate
    );
    
    if (!eventAnalysis.impact || eventAnalysis.impact.length === 0) {
        return;
    }
    
    // Use top 5 events with significant impact
    const impactEvents = eventAnalysis.impact
        .filter(event => Math.abs(event.percentChange || 0) > 10)
        .slice(0, 5);
    
    if (impactEvents.length === 0) {
        return;
    }
    
    // Create chart
    if (charts.eventsImpact) charts.eventsImpact.destroy();
    charts.eventsImpact = new Chart(
        document.getElementById('events-impact-chart'),
        {
            type: 'bar',
            data: {
                labels: impactEvents.map(event => 
                    event.event.length > 15 ? 
                    event.event.substring(0, 15) + '...' : event.event
                ),
                datasets: [{
                    label: 'Percent Change in 311 Calls',
                    data: impactEvents.map(event => event.percentChange),
                    backgroundColor: impactEvents.map(event => 
                        event.percentChange >= 0 ? '#8B5CF6' : '#EF4444'
                    )
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Events Impact on 311 Calls',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Change: ${value.toFixed(1)}%`;
                            },
                            footer: function(tooltipItems) {
                                const idx = tooltipItems[0].dataIndex;
                                const event = impactEvents[idx];
                                return `${event.borough} - ${event.date}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Percent Change',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

================================================================================

FILE: dataLoader.js
LINES: 682
--------------------------------------------------------------------------------

/**
 * Data loading and parsing functionality for NYC Urban Rhythm
 */

// State variables to store loaded data
let all311Data = [];
let transitData = [];
let taxiData = [];
let eventsData = [];
let dateRangeInitialized = false;

// Reference to DOM elements
const dom = {
    // File input elements
    fileInputs: {
        calls311: document.getElementById('csv311'),
        transit: document.getElementById('csvMTA'),
        taxi: document.getElementById('csvTLC'),
        events: document.getElementById('csvEvents')
    },
    // Date range controls
    dateControls: {
        start: document.getElementById('startDate'),
        end: document.getElementById('endDate'),
        updateBtn: document.getElementById('updateDashboardBtn')
    },
    // Info display
    infoPanel: document.getElementById('info-text')
};

/**
 * Initialize data loaders for all file inputs
 */
function initializeDataLoaders() {
    // Set up event listeners for file inputs
    dom.fileInputs.calls311.addEventListener('change', handle311DataLoad);
    dom.fileInputs.transit.addEventListener('change', handleTransitDataLoad);
    dom.fileInputs.taxi.addEventListener('change', handleTaxiDataLoad);
    dom.fileInputs.events.addEventListener('change', handleEventsDataLoad);
    
    // Disable date controls initially
    disableDateControls();
}

/**
 * Disable date range controls
 */
function disableDateControls() {
    dom.dateControls.start.disabled = true;
    dom.dateControls.end.disabled = true;
    dom.dateControls.updateBtn.disabled = true;
}

/**
 * Enable date range controls
 */
function enableDateControls() {
    dom.dateControls.start.disabled = false;
    dom.dateControls.end.disabled = false;
    dom.dateControls.updateBtn.disabled = false;
}

/**
 * Handle loading of 311 call data 
 */
function handle311DataLoad() {
    disableDateControls();
    showLoading('Loading 311 data...');
    all311Data = [];
    
    try {
        const files = Array.from(dom.fileInputs.calls311.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    const d = parseDateFlexible(row.data.created_date);
                    if (!d) return;
                    
                    const pd = formatDate(d);
                    const time = d.toTimeString().substring(0, 5);
                    const hour = d.getHours();
                    const dow = d.getDay();
                    const rawBoro = (row.data.borough || '').trim();
                    
                    // Format borough name consistently
                    const borough = rawBoro
                        .toLowerCase()
                        .split(' ')
                        .map(w => w[0]?.toUpperCase() + w.slice(1))
                        .join(' ');
                        
                    const complaint = (row.data.complaint_type || '').trim();
                    const descriptor = (row.data.descriptor || '').trim();
                    
                    // Only include records with valid boroughs
                    if (Object.keys(BOROUGH_CENTROIDS).includes(borough)) {
                        all311Data.push({ 
                            parsed_date: pd, 
                            time, 
                            hour, 
                            dow,
                            borough, 
                            complaint,
                            descriptor,
                            lat: parseFloat(row.data.latitude || 0),
                            lng: parseFloat(row.data.longitude || 0),
                            dataset: 'calls311'
                        });
                    }
                },
                complete: () => { 
                    completed++;
                    if (completed === files.length) {
                        finalize311Data();
                    }
                },
                error: err => {
                    console.error('Error parsing 311 CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        finalize311Data();
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} 311 data files...`);
    } catch (error) {
        console.error('Error loading 311 data:', error);
        updateInfoText('Error loading 311 data.');
        hideLoading();
    }
}

/**
 * Finalize 311 data loading
 */
function finalize311Data() {
    hideLoading();
    
    if (!all311Data.length) {
        updateInfoText('No valid 311 data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    all311Data.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls
    dom.dateControls.start.min = dom.dateControls.end.min = minDate;
    dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
    dom.dateControls.start.value = minDate;
    dom.dateControls.end.value = maxDate;
    
    // Enable controls
    enableDateControls();
    
    // Update info
    updateInfoText(`Loaded ${all311Data.length} 311 records. Range: ${minDate} to ${maxDate}`);
    
    // Mark date range as initialized and show timeline
    dateRangeInitialized = true;
    document.getElementById('timeline-control').classList.remove('hidden');
}

/**
 * Handle loading of MTA transit data
 */
function handleTransitDataLoad() {
    disableDateControls();
    showLoading('Loading transit data...');
    transitData = [];
    
    try {
        const files = Array.from(dom.fileInputs.transit.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    const timestamp = parseDateFlexible(row.data.transit_timestamp);
                    if (!timestamp) return;
                    
                    const pd = formatDate(timestamp);
                    const time = timestamp.toTimeString().substring(0, 5);
                    const hour = timestamp.getHours();
                    const dow = timestamp.getDay();
                    
                    // Parse georeference if available
                    let lat = null, lng = null;
                    if (row.data.latitude && row.data.longitude) {
                        lat = parseFloat(row.data.latitude);
                        lng = parseFloat(row.data.longitude);
                    } else if (row.data.georeference) {
                        try {
                            const geoData = JSON.parse(row.data.georeference.replace(/'/g, '"'));
                            if (geoData.coordinates && geoData.coordinates.length >= 2) {
                                lng = geoData.coordinates[0];
                                lat = geoData.coordinates[1];
                            }
                        } catch (e) {
                            // Unable to parse georeference
                        }
                    }
                    
                    const ridership = parseFloat(row.data.ridership) || 0;
                    const borough = row.data.borough;
                    
                    if (borough && Object.keys(BOROUGH_CENTROIDS).includes(borough)) {
                        transitData.push({
                            transit_timestamp: row.data.transit_timestamp,
                            parsed_date: pd,
                            time,
                            hour,
                            dow,
                            station_complex: row.data.station_complex,
                            station_complex_id: row.data.station_complex_id,
                            borough,
                            ridership,
                            lat,
                            lng,
                            payment_method: row.data.payment_method,
                            dataset: 'transit'
                        });
                    }
                },
                complete: () => {
                    completed++;
                    if (completed === files.length) {
                        finalizeTransitData();
                    }
                },
                error: err => {
                    console.error('Error parsing transit CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        finalizeTransitData();
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} transit data files...`);
    } catch (error) {
        console.error('Error loading transit data:', error);
        updateInfoText('Error loading transit data.');
        hideLoading();
    }
}

/**
 * Finalize transit data loading
 */
function finalizeTransitData() {
    hideLoading();
    
    if (!transitData.length) {
        updateInfoText('No valid transit data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    transitData.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls if not already initialized
    if (!dateRangeInitialized) {
        dom.dateControls.start.min = dom.dateControls.end.min = minDate;
        dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
        dom.dateControls.start.value = minDate;
        dom.dateControls.end.value = maxDate;
        
        // Enable controls
        enableDateControls();
        
        // Mark date range as initialized and show timeline
        dateRangeInitialized = true;
        document.getElementById('timeline-control').classList.remove('hidden');
    }
    
    // Update info
    updateInfoText(`Loaded ${transitData.length} transit records. Range: ${minDate} to ${maxDate}`);
}

/**
 * Handle loading of TLC taxi trip data
 */
function handleTaxiDataLoad() {
    disableDateControls();
    showLoading('Loading taxi data...');
    taxiData = [];
    
    try {
        const files = Array.from(dom.fileInputs.taxi.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    // Try to get the pickup and dropoff timestamps
                    const pickupTime = row.data.pickup_datetime || row.data.tpep_pickup_datetime;
                    const dropoffTime = row.data.dropoff_datetime || row.data.tpep_dropoff_datetime;
                    
                    if (!pickupTime) return;
                    
                    const pickup = parseDateFlexible(pickupTime);
                    const dropoff = parseDateFlexible(dropoffTime);
                    
                    if (!pickup || !dropoff) return;
                    
                    const pd = formatDate(pickup);
                    const time = pickup.toTimeString().substring(0, 5);
                    const hour = pickup.getHours();
                    const dow = pickup.getDay();
                    
                    // Get zone IDs
                    const puLocationId = parseInt(row.data.pulocationid);
                    const doLocationId = parseInt(row.data.dolocationid);
                    
                    // Try to determine borough from location IDs
                    const puBorough = ZONE_TO_BOROUGH[puLocationId];
                    const doBorough = ZONE_TO_BOROUGH[doLocationId];
                    
                    // Only include if we can determine at least one borough
                    if (puBorough || doBorough) {
                        taxiData.push({
                            pickup_datetime: pickupTime,
                            dropoff_datetime: dropoffTime,
                            parsed_date: pd,
                            time,
                            hour,
                            dow,
                            trip_distance: parseFloat(row.data.trip_distance) || 0,
                            passenger_count: parseInt(row.data.passenger_count) || 1,
                            fare_amount: parseFloat(row.data.fare_amount) || 0,
                            tip_amount: parseFloat(row.data.tip_amount) || 0,
                            total_amount: parseFloat(row.data.total_amount) || 0,
                            pu_location_id: puLocationId,
                            do_location_id: doLocationId,
                            pu_borough: puBorough,
                            do_borough: doBorough,
                            dataset: 'taxi'
                        });
                    }
                },
                complete: () => {
                    completed++;
                    if (completed === files.length) {
                        finalizeTaxiData();
                    }
                },
                error: err => {
                    console.error('Error parsing taxi CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        finalizeTaxiData();
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} taxi data files...`);
    } catch (error) {
        console.error('Error loading taxi data:', error);
        updateInfoText('Error loading taxi data.');
        hideLoading();
    }
}

/**
 * Finalize taxi data loading
 */
function finalizeTaxiData() {
    hideLoading();
    
    if (!taxiData.length) {
        updateInfoText('No valid taxi data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    taxiData.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls if not already initialized
    if (!dateRangeInitialized) {
        dom.dateControls.start.min = dom.dateControls.end.min = minDate;
        dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
        dom.dateControls.start.value = minDate;
        dom.dateControls.end.value = maxDate;
        
        // Enable controls
        enableDateControls();
        
        // Mark date range as initialized and show timeline
        dateRangeInitialized = true;
        document.getElementById('timeline-control').classList.remove('hidden');
    }
    
    // Update info
    updateInfoText(`Loaded ${taxiData.length} taxi records. Range: ${minDate} to ${maxDate}`);
}

/**
 * Handle loading of NYC events data
 */
function handleEventsDataLoad() {
    disableDateControls();
    showLoading('Loading events data...');
    eventsData = [];
    
    try {
        const files = Array.from(dom.fileInputs.events.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    const startTime = row.data.start_datetime || row.data.start_date_time;
                    const endTime = row.data.end_datetime || row.data.end_date_time;
                    
                    if (!startTime) return;
                    
                    const start = parseDateFlexible(startTime);
                    const end = parseDateFlexible(endTime);
                    
                    if (!start) return;
                    
                    const pd = formatDate(start);
                    const time = start.toTimeString().substring(0, 5);
                    const hour = start.getHours();
                    const dow = start.getDay();
                    
                    const borough = row.data.event_borough;
                    const location = row.data.event_location;
                    
                    if (borough && Object.keys(BOROUGH_CENTROIDS).includes(borough)) {
                        // Use borough centroid as default location
                        const [lat, lng] = BOROUGH_CENTROIDS[borough];
                        
                        eventsData.push({
                            event_id: row.data.event_id,
                            event_name: row.data.event_name,
                            start_datetime: startTime,
                            end_datetime: endTime,
                            parsed_date: pd,
                            time,
                            hour,
                            dow,
                            event_agency: row.data.event_agency,
                            event_type: row.data.event_type,
                            borough,
                            location,
                            lat,
                            lng,
                            dataset: 'events'
                        });
                    }
                },
                complete: () => {
                    completed++;
                    if (completed === files.length) {
                        // First geocode events, then finalize
                        geocodeEventLocations().finally(() => {
                            finalizeEventsData();
                        });
                    }
                },
                error: err => {
                    console.error('Error parsing events CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        // Even if parsing had errors, try to geocode and finalize
                        geocodeEventLocations().finally(() => {
                            finalizeEventsData();
                        });
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} event data files...`);
    } catch (error) {
        console.error('Error loading events data:', error);
        updateInfoText('Error loading events data.');
        hideLoading();
    }
}

/**
 * Attempt to geocode event locations to get better coordinates
 */
async function geocodeEventLocations() {
    // Only process a few events to avoid rate limits
    const MAX_GEOCODING = 20;
    const eventsToGeocode = eventsData
        .filter(event => event.location && event.location.length > 3)
        .slice(0, MAX_GEOCODING);
    
    for (const event of eventsToGeocode) {
        try {
            const query = `${event.location}, ${event.borough}, New York City`;
            const url = `${API_CONFIG.geocodingEndpoint}${encodeURIComponent(query)}.json?access_token=${MAPBOX_ACCESS_TOKEN}&limit=1`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.features && data.features.length > 0) {
                const [lng, lat] = data.features[0].center;
                event.lng = lng;
                event.lat = lat;
            }
            
            // Add a small delay to avoid rate limits
            await new Promise(resolve => setTimeout(resolve, 300));
        } catch (error) {
            console.error('Error geocoding event location:', error);
        }
    }
}

/**
 * Finalize events data loading
 */
function finalizeEventsData() {
    hideLoading();
    
    if (!eventsData.length) {
        updateInfoText('No valid events data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    eventsData.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls if not already initialized
    if (!dateRangeInitialized) {
        dom.dateControls.start.min = dom.dateControls.end.min = minDate;
        dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
        dom.dateControls.start.value = minDate;
        dom.dateControls.end.value = maxDate;
        
        // Enable controls
        enableDateControls();
        
        // Mark date range as initialized and show timeline
        dateRangeInitialized = true;
        document.getElementById('timeline-control').classList.remove('hidden');
    }
    
    // Update info
    updateInfoText(`Loaded ${eventsData.length} event records. Range: ${minDate} to ${maxDate}`);
}

/**
 * Get all datasets filtered by date range
 */
function getFilteredDatasets(startDate, endDate) {
    // Filter all datasets by date range
    const filtered311 = all311Data.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    const filteredTransit = transitData.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    const filteredTaxi = taxiData.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    // For events, include those that overlap with the date range
    const filteredEvents = eventsData.filter(item => {
        const eventStart = new Date(item.start_datetime);
        const eventEnd = new Date(item.end_datetime);
        const rangeStart = new Date(startDate);
        const rangeEnd = new Date(endDate);
        
        // Check if event overlaps with date range
        return (eventStart <= rangeEnd && eventEnd >= rangeStart);
    });
    
    return {
        calls311: filtered311,
        transit: filteredTransit,
        taxi: filteredTaxi,
        events: filteredEvents
    };
}

/**
 * Get dataset statistics
 */
function getDatasetStats(filteredData) {
    const stats = {
        calls311: filteredData.calls311.length,
        transit: filteredData.transit.reduce((sum, item) => sum + (parseFloat(item.ridership) || 0), 0),
        taxi: filteredData.taxi.length,
        events: filteredData.events.length
    };
    
    return stats;
}

/**
 * Update stats summary in UI
 */
function updateStatsSummary(stats) {
    document.getElementById('stat-311').textContent = `311 Calls: ${formatNumber(stats.calls311)}`;
    document.getElementById('stat-transit').textContent = `Subway Entries: ${formatNumber(Math.round(stats.transit))}`;
    document.getElementById('stat-taxi').textContent = `Taxi Trips: ${formatNumber(stats.taxi)}`;
    document.getElementById('stat-events').textContent = `Events: ${formatNumber(stats.events)}`;
    document.getElementById('stats-summary').classList.remove('hidden');
}

================================================================================

FILE: dataProcessor.js
LINES: 753
--------------------------------------------------------------------------------

/**
 * Data processing and aggregation for NYC Urban Rhythm
 */

// Processed data storage
let processedData = {
    calls311: {},
    transit: {},
    taxi: {},
    events: {},
    weather: {}
};

/**
 * Process and aggregate all datasets based on date range
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format  
 * @param {Object} filteredData - Object containing filtered datasets
 * @returns {Object} - Aggregated data for visualization
 */
function processAllData(startDate, endDate, filteredData) {
    // Reset processed data
    processedData = {
        calls311: {},
        transit: {},
        taxi: {},
        events: {},
        weather: {}
    };
    
    // Process 311 call data
    process311Data(filteredData.calls311);
    
    // Process transit data
    processTransitData(filteredData.transit);
    
    // Process taxi data
    processTaxiData(filteredData.taxi);
    
    // Process events data
    processEventsData(filteredData.events);
    
    return processedData;
}

/**
 * Process 311 call data
 * @param {Array} data - Filtered 311 call data 
 */
function process311Data(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate calls by borough
    const aggregatedByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by complaint type
    const complaintTypes = {};
    
    // Aggregate by hour
    const hourlyByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(24).fill(0);
        return acc;
    }, {});
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Process each record
    data.forEach(record => {
        const borough = record.borough;
        
        // Increment borough count
        aggregatedByBorough[borough]++;
        
        // Increment complaint type count
        if (!complaintTypes[record.complaint]) {
            complaintTypes[record.complaint] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        complaintTypes[record.complaint].total++;
        complaintTypes[record.complaint].byBorough[borough]++;
        
        // Increment hourly count
        hourlyByBorough[borough][record.hour]++;
        
        // Increment day of week count
        dowByBorough[borough][record.dow]++;
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total++;
        dailyData[record.parsed_date].byBorough[borough]++;
    });
    
    // Store processed data
    processedData.calls311 = {
        totalByBorough: aggregatedByBorough,
        complaintTypes,
        hourlyByBorough,
        dailyData,
        dowByBorough
    };
}

/**
 * Process transit data
 * @param {Array} data - Filtered transit data
 */
function processTransitData(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate ridership by borough
    const ridershipByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by station
    const stationRidership = {};
    
    // Aggregate by hour
    const hourlyByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(24).fill(0);
        return acc;
    }, {});
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Aggregate by payment method
    const paymentMethods = {};
    
    // Process each record
    data.forEach(record => {
        const borough = record.borough;
        const ridership = parseFloat(record.ridership) || 0;
        
        // Increment borough ridership
        ridershipByBorough[borough] += ridership;
        
        // Increment station ridership
        if (!stationRidership[record.station_complex]) {
            stationRidership[record.station_complex] = {
                id: record.station_complex_id,
                total: 0,
                byHour: Array(24).fill(0),
                lat: record.lat,
                lng: record.lng,
                borough
            };
        }
        stationRidership[record.station_complex].total += ridership;
        stationRidership[record.station_complex].byHour[record.hour] += ridership;
        
        // Increment hourly count
        hourlyByBorough[borough][record.hour] += ridership;
        
        // Increment day of week count
        dowByBorough[borough][record.dow] += ridership;
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total += ridership;
        dailyData[record.parsed_date].byBorough[borough] += ridership;
        
        // Aggregate by payment method
        const method = record.payment_method || 'Unknown';
        if (!paymentMethods[method]) {
            paymentMethods[method] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        paymentMethods[method].total += ridership;
        paymentMethods[method].byBorough[borough] += ridership;
    });
    
    // Store processed data
    processedData.transit = {
        ridershipByBorough,
        stationRidership,
        hourlyByBorough,
        dailyData,
        dowByBorough,
        paymentMethods
    };
}

/**
 * Process taxi data
 * @param {Array} data - Filtered taxi data
 */
function processTaxiData(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate pickups by borough
    const pickupsByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate dropoffs by borough
    const dropoffsByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by hour
    const hourlyByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(24).fill(0);
        return acc;
    }, {});
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Track distance and fare metrics
    const metrics = {
        avgDistance: 0,
        avgFare: 0,
        avgTip: 0,
        distanceByBorough: validBoroughs.reduce((acc, borough) => {
            acc[borough] = [];
            return acc;
        }, {}),
        fareByBorough: validBoroughs.reduce((acc, borough) => {
            acc[borough] = [];
            return acc;
        }, {})
    };
    
    // Process each record
    data.forEach(record => {
        // Add to pickup borough counts
        if (record.pu_borough && validBoroughs.includes(record.pu_borough)) {
            pickupsByBorough[record.pu_borough]++;
            hourlyByBorough[record.pu_borough][record.hour]++;
            dowByBorough[record.pu_borough][record.dow]++;
            
            // Add to metrics
            metrics.distanceByBorough[record.pu_borough].push(record.trip_distance);
            metrics.fareByBorough[record.pu_borough].push(record.fare_amount);
        }
        
        // Add to dropoff borough counts
        if (record.do_borough && validBoroughs.includes(record.do_borough)) {
            dropoffsByBorough[record.do_borough]++;
        }
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total++;
        
        if (record.pu_borough && validBoroughs.includes(record.pu_borough)) {
            dailyData[record.parsed_date].byBorough[record.pu_borough]++;
        }
        
        // Add to overall metrics
        metrics.avgDistance += record.trip_distance;
        metrics.avgFare += record.fare_amount;
        metrics.avgTip += record.tip_amount;
    });
    
    // Calculate averages
    if (data.length > 0) {
        metrics.avgDistance /= data.length;
        metrics.avgFare /= data.length;
        metrics.avgTip /= data.length;
    }
    
    // Calculate borough averages
    validBoroughs.forEach(borough => {
        const distances = metrics.distanceByBorough[borough];
        const fares = metrics.fareByBorough[borough];
        
        metrics.distanceByBorough[borough] = distances.length > 0 
            ? distances.reduce((sum, val) => sum + val, 0) / distances.length 
            : 0;
            
        metrics.fareByBorough[borough] = fares.length > 0 
            ? fares.reduce((sum, val) => sum + val, 0) / fares.length 
            : 0;
    });
    
    // Store processed data
    processedData.taxi = {
        pickupsByBorough,
        dropoffsByBorough,
        hourlyByBorough,
        dailyData,
        dowByBorough,
        metrics
    };
}

/**
 * Process events data
 * @param {Array} data - Filtered events data
 */
function processEventsData(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate events by borough
    const eventsByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by event type
    const eventTypes = {};
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Aggregate by agency
    const eventAgencies = {};
    
    // Process each record
    data.forEach(record => {
        const borough = record.borough;
        
        // Increment borough count
        eventsByBorough[borough]++;
        
        // Increment event type count
        const type = record.event_type || 'Unknown';
        if (!eventTypes[type]) {
            eventTypes[type] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        eventTypes[type].total++;
        eventTypes[type].byBorough[borough]++;
        
        // Increment day of week count
        dowByBorough[borough][record.dow]++;
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total++;
        dailyData[record.parsed_date].byBorough[borough]++;
        
        // Aggregate by agency
        const agency = record.event_agency || 'Unknown';
        if (!eventAgencies[agency]) {
            eventAgencies[agency] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        eventAgencies[agency].total++;
        eventAgencies[agency].byBorough[borough]++;
    });
    
    // Store processed data
    processedData.events = {
        eventsByBorough,
        eventTypes,
        dailyData,
        dowByBorough,
        eventAgencies,
        eventsList: data.map(event => ({
            id: event.event_id,
            name: event.event_name,
            start: event.start_datetime,
            end: event.end_datetime,
            borough: event.borough,
            location: event.location,
            type: event.event_type,
            lat: event.lat,
            lng: event.lng
        }))
    };
}

/**
 * Calculate correlations between datasets
 * @returns {Object} - Correlation analysis results
 */
function calculateDatasetCorrelations() {
    const correlations = {
        transitVs311: {},
        taxiVs311: {},
        eventsImpact: []
    };
    
    console.log("Data available for correlations:", {
        "311 daily data": processedData.calls311.dailyData ? Object.keys(processedData.calls311.dailyData).length : 0,
        "Transit daily data": processedData.transit.dailyData ? Object.keys(processedData.transit.dailyData).length : 0,
        "Taxi daily data": processedData.taxi.dailyData ? Object.keys(processedData.taxi.dailyData).length : 0
    });
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);

    
    // Only proceed if we have data for all required datasets
    if (!processedData.calls311.dailyData || 
        !processedData.transit.dailyData ||
        !processedData.taxi.dailyData) {
        return correlations;
    }
    
    // Get all dates that exist in all three datasets
    const dates = Object.keys(processedData.calls311.dailyData).filter(date => 
        processedData.transit.dailyData[date] && 
        processedData.taxi.dailyData[date]
    );
    
    if (dates.length === 0) {
        return correlations;
    }
    
    // // Calculate borough-level correlations
    // const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    validBoroughs.forEach(borough => {
        // Get daily activity for this borough
        const calls311 = dates.map(date => 
            processedData.calls311.dailyData[date].byBorough[borough] || 0
        );
        
        const transit = dates.map(date => 
            processedData.transit.dailyData[date].byBorough[borough] || 0
        );
        
        const taxi = dates.map(date => 
            processedData.taxi.dailyData[date].byBorough[borough] || 0
        );
        
        // Calculate correlations
        correlations.transitVs311[borough] = calculateCorrelation(transit, calls311);
        correlations.taxiVs311[borough] = calculateCorrelation(taxi, calls311);
    });
    
    // Calculate event impact
    // If we have event data, analyze the impact on other activity
    if (processedData.events.eventsList && processedData.events.eventsList.length > 0) {
        const eventImpacts = [];
        
        processedData.events.eventsList.forEach(event => {
            // Get dates before, during, and after event
            const eventDate = new Date(event.start);
            const dayBefore = formatDate(new Date(eventDate.getTime() - 86400000));
            const eventDay = formatDate(eventDate);
            const dayAfter = formatDate(new Date(eventDate.getTime() + 86400000));
            
            // Calculate impact if we have data for all three days
            if (processedData.calls311.dailyData[dayBefore] && 
                processedData.calls311.dailyData[eventDay] && 
                processedData.calls311.dailyData[dayAfter]) {
                
                const borough = event.borough;
                
                // Calculate percent change in 311 calls
                const beforeCalls = processedData.calls311.dailyData[dayBefore].byBorough[borough] || 0;
                const duringCalls = processedData.calls311.dailyData[eventDay].byBorough[borough] || 0;
                const afterCalls = processedData.calls311.dailyData[dayAfter].byBorough[borough] || 0;
                
                // Only include if there were calls on the before day (avoid divide by zero)
                if (beforeCalls > 0) {
                    const percentChange = ((duringCalls - beforeCalls) / beforeCalls) * 100;
                    
                    eventImpacts.push({
                        event: event.name,
                        borough,
                        date: eventDay,
                        percentChange,
                        beforeCalls,
                        duringCalls,
                        afterCalls
                    });
                }
            }
        });
        
        // Sort by absolute impact
        eventImpacts.sort((a, b) => Math.abs(b.percentChange) - Math.abs(a.percentChange));
        
        correlations.eventsImpact = eventImpacts;
    }
    
    // Before returning, log the calculated correlations
    console.log("Calculated correlations:", {
        transitVs311: correlations.transitVs311,
        taxiVs311: correlations.taxiVs311,
        eventsImpactCount: correlations.eventsImpact.length
    });
    
    return correlations;
}

/**
 * Calculate neighborhood rhythm scores
 * @returns {Object} - Rhythm scores by borough and time
 */
function calculateRhythmScores() {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const rhythms = {};
    
    validBoroughs.forEach(borough => {
        // Initialize rhythm object for this borough
        rhythms[borough] = {
            hourly: Array(24).fill(0),
            dow: Array(7).fill(0),
            overallActivity: 0,
            peakHour: 0,
            peakDay: 0
        };
        
        // Add 311 calls contribution
        if (processedData.calls311.hourlyByBorough && processedData.calls311.dowByBorough) {
            for (let i = 0; i < 24; i++) {
                rhythms[borough].hourly[i] += processedData.calls311.hourlyByBorough[borough][i] || 0;
            }
            for (let i = 0; i < 7; i++) {
                rhythms[borough].dow[i] += processedData.calls311.dowByBorough[borough][i] || 0;
            }
            rhythms[borough].overallActivity += processedData.calls311.totalByBorough[borough] || 0;
        }
        
        // Add transit contribution
        if (processedData.transit.hourlyByBorough && processedData.transit.dowByBorough) {
            // Transit data has larger numbers, so scale it down
            const transitScale = 0.1;
            for (let i = 0; i < 24; i++) {
                rhythms[borough].hourly[i] += (processedData.transit.hourlyByBorough[borough][i] || 0) * transitScale;
            }
            for (let i = 0; i < 7; i++) {
                rhythms[borough].dow[i] += (processedData.transit.dowByBorough[borough][i] || 0) * transitScale;
            }
            rhythms[borough].overallActivity += (processedData.transit.ridershipByBorough[borough] || 0) * transitScale;
        }
        
        // Add taxi contribution
        if (processedData.taxi.hourlyByBorough && processedData.taxi.dowByBorough) {
            for (let i = 0; i < 24; i++) {
                rhythms[borough].hourly[i] += processedData.taxi.hourlyByBorough[borough][i] || 0;
            }
            for (let i = 0; i < 7; i++) {
                rhythms[borough].dow[i] += processedData.taxi.dowByBorough[borough][i] || 0;
            }
            rhythms[borough].overallActivity += processedData.taxi.pickupsByBorough[borough] || 0;
        }
        
        // Find peak hour and day
        let maxHour = 0, maxHourVal = 0;
        let maxDay = 0, maxDayVal = 0;
        
        for (let i = 0; i < 24; i++) {
            if (rhythms[borough].hourly[i] > maxHourVal) {
                maxHourVal = rhythms[borough].hourly[i];
                maxHour = i;
            }
        }
        
        for (let i = 0; i < 7; i++) {
            if (rhythms[borough].dow[i] > maxDayVal) {
                maxDayVal = rhythms[borough].dow[i];
                maxDay = i;
            }
        }
        
        rhythms[borough].peakHour = maxHour;
        rhythms[borough].peakDay = maxDay;
    });
    
    return rhythms;
}

/**
 * Detect activity clusters across datasets
 * @returns {Array} - Detected activity clusters
 */
function detectActivityClusters() {
    const clusters = [];
    const allPoints = [];
    
    // Collect points from all datasets
    if (processedData.calls311.totalByBorough) {
        all311Data.forEach(point => {
            if (point.lat && point.lng) {
                allPoints.push({
                    lat: point.lat,
                    lng: point.lng,
                    type: 'calls311',
                    hour: point.hour,
                    dow: point.dow,
                    date: point.parsed_date
                });
            }
        });
    }
    
    if (processedData.transit.stationRidership) {
        Object.values(processedData.transit.stationRidership).forEach(station => {
            if (station.lat && station.lng) {
                allPoints.push({
                    lat: station.lat,
                    lng: station.lng,
                    type: 'transit',
                    value: station.total
                });
            }
        });
    }
    
    if (processedData.events.eventsList) {
        processedData.events.eventsList.forEach(event => {
            if (event.lat && event.lng) {
                allPoints.push({
                    lat: event.lat,
                    lng: event.lng,
                    type: 'event',
                    name: event.name,
                    date: event.start
                });
            }
        });
    }
    
    // Skip clustering if we don't have enough points
    if (allPoints.length < 10) return clusters;
    
    // Very basic clustering - group by grid cells
    const gridSize = 0.005; // Roughly 500m at NYC latitude
    const gridCells = {};
    
    allPoints.forEach(point => {
        const gridX = Math.floor(point.lng / gridSize);
        const gridY = Math.floor(point.lat / gridSize);
        const key = `${gridX}:${gridY}`;
        
        if (!gridCells[key]) {
            gridCells[key] = {
                points: [],
                center: {
                    lat: (gridY + 0.5) * gridSize,
                    lng: (gridX + 0.5) * gridSize
                },
                types: {}
            };
        }
        
        gridCells[key].points.push(point);
        
        if (!gridCells[key].types[point.type]) {
            gridCells[key].types[point.type] = 0;
        }
        gridCells[key].types[point.type]++;
    });
    
    // Convert grid cells to clusters
    Object.entries(gridCells).forEach(([key, cell]) => {
        // Only include cells with multiple points
        if (cell.points.length >= 3) {
            // Determine cluster type based on dominant activity
            let maxType = '', maxCount = 0;
            Object.entries(cell.types).forEach(([type, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    maxType = type;
                }
            });
            
            clusters.push({
                center: cell.center,
                pointCount: cell.points.length,
                types: cell.types,
                dominant: maxType
            });
        }
    });
    
    // Sort clusters by point count
    clusters.sort((a, b) => b.pointCount - a.pointCount);
    
    return clusters;
}

================================================================================

FILE: eventAnalysis.js
LINES: 417
--------------------------------------------------------------------------------

/**
 * Event analysis functionality for NYC Urban Rhythm
 */

/**
 * Analyze event impact on urban activity
 * @param {Array} events - Event data
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Object} - Event impact analysis
 */
function analyzeEventImpact(events, startDate, endDate) {
    // Filter events that fall within date range
    const filteredEvents = events.filter(event => {
        const eventStart = new Date(event.start_datetime);
        const eventEnd = new Date(event.end_datetime);
        const rangeStart = new Date(startDate);
        const rangeEnd = new Date(endDate);
        
        // Check if event overlaps with date range
        return (eventStart <= rangeEnd && eventEnd >= rangeStart);
    });
    
    // Initialize analysis object
    const analysis = {
        eventCount: filteredEvents.length,
        byBorough: {},
        byType: {},
        impact: []
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Initialize borough and type counts
    validBoroughs.forEach(borough => {
        analysis.byBorough[borough] = 0;
    });
    
    // Count events by borough and type
    filteredEvents.forEach(event => {
        // Count by borough
        if (analysis.byBorough[event.borough] !== undefined) {
            analysis.byBorough[event.borough]++;
        }
        
        // Count by type
        const type = event.event_type || 'Unknown';
        if (!analysis.byType[type]) {
            analysis.byType[type] = 0;
        }
        analysis.byType[type]++;
    });
    
    // Analyze impact of each event on urban activity
    filteredEvents.forEach(event => {
        const eventDate = formatDate(new Date(event.start_datetime));
        const eventBorough = event.borough;
        
        // Get day before and after event
        const eventDay = new Date(event.start_datetime);
        const dayBefore = formatDate(new Date(eventDay.getTime() - 86400000)); // 1 day in milliseconds
        const dayAfter = formatDate(new Date(eventDay.getTime() + 86400000));
        
        // Check if we have data for all three days
        if (processedData.calls311.dailyData && 
            processedData.calls311.dailyData[dayBefore] && 
            processedData.calls311.dailyData[eventDate] && 
            processedData.calls311.dailyData[dayAfter]) {
            
            // Calculate impact on 311 calls
            const beforeCalls = processedData.calls311.dailyData[dayBefore].byBorough[eventBorough] || 0;
            const duringCalls = processedData.calls311.dailyData[eventDate].byBorough[eventBorough] || 0;
            const afterCalls = processedData.calls311.dailyData[dayAfter].byBorough[eventBorough] || 0;
            
            // Only include if there were calls on the before day (avoid divide by zero)
            if (beforeCalls > 0) {
                const percentChange = ((duringCalls - beforeCalls) / beforeCalls) * 100;
                
                // Check for significant change
                if (Math.abs(percentChange) > 10) {
                    analysis.impact.push({
                        event: event.event_name,
                        date: eventDate,
                        borough: eventBorough,
                        percentChange,
                        beforeCalls,
                        duringCalls,
                        afterCalls,
                        lat: event.lat,
                        lng: event.lng
                    });
                }
            }
        }
        
        // Check impact on transit ridership
        if (processedData.transit.dailyData && 
            processedData.transit.dailyData[dayBefore] && 
            processedData.transit.dailyData[eventDate] && 
            processedData.transit.dailyData[dayAfter]) {
            
            // Calculate transit impact
            const beforeRidership = processedData.transit.dailyData[dayBefore].byBorough[eventBorough] || 0;
            const duringRidership = processedData.transit.dailyData[eventDate].byBorough[eventBorough] || 0;
            const afterRidership = processedData.transit.dailyData[dayAfter].byBorough[eventBorough] || 0;
            
            // Only include if there was ridership on the before day
            if (beforeRidership > 0) {
                const percentChange = ((duringRidership - beforeRidership) / beforeRidership) * 100;
                
                // Check for significant change
                if (Math.abs(percentChange) > 10) {
                    // Add transit impact
                    const existingImpact = analysis.impact.find(i => 
                        i.event === event.event_name && i.date === eventDate
                    );
                    
                    if (existingImpact) {
                        existingImpact.transitChange = percentChange;
                        existingImpact.beforeRidership = beforeRidership;
                        existingImpact.duringRidership = duringRidership;
                    } else {
                        analysis.impact.push({
                            event: event.event_name,
                            date: eventDate,
                            borough: eventBorough,
                            transitChange: percentChange,
                            beforeRidership,
                            duringRidership,
                            afterRidership,
                            lat: event.lat,
                            lng: event.lng
                        });
                    }
                }
            }
        }
        
        // Check impact on taxi pickups
        if (processedData.taxi.dailyData && 
            processedData.taxi.dailyData[dayBefore] && 
            processedData.taxi.dailyData[eventDate] && 
            processedData.taxi.dailyData[dayAfter]) {
            
            // Calculate taxi impact
            const beforePickups = processedData.taxi.dailyData[dayBefore].byBorough[eventBorough] || 0;
            const duringPickups = processedData.taxi.dailyData[eventDate].byBorough[eventBorough] || 0;
            const afterPickups = processedData.taxi.dailyData[dayAfter].byBorough[eventBorough] || 0;
            
            // Only include if there were pickups on the before day
            if (beforePickups > 0) {
                const percentChange = ((duringPickups - beforePickups) / beforePickups) * 100;
                
                // Check for significant change
                if (Math.abs(percentChange) > 10) {
                    // Add taxi impact
                    const existingImpact = analysis.impact.find(i => 
                        i.event === event.event_name && i.date === eventDate
                    );
                    
                    if (existingImpact) {
                        existingImpact.taxiChange = percentChange;
                        existingImpact.beforePickups = beforePickups;
                        existingImpact.duringPickups = duringPickups;
                    } else {
                        analysis.impact.push({
                            event: event.event_name,
                            date: eventDate,
                            borough: eventBorough,
                            taxiChange: percentChange,
                            beforePickups,
                            duringPickups,
                            afterPickups,
                            lat: event.lat,
                            lng: event.lng
                        });
                    }
                }
            }
        }
    });
    
    // Sort impact by magnitude
    analysis.impact.sort((a, b) => {
        const aMax = Math.max(
            Math.abs(a.percentChange || 0),
            Math.abs(a.transitChange || 0),
            Math.abs(a.taxiChange || 0)
        );
        
        const bMax = Math.max(
            Math.abs(b.percentChange || 0),
            Math.abs(b.transitChange || 0),
            Math.abs(b.taxiChange || 0)
        );
        
        return bMax - aMax;
    });
    
    return analysis;
}

/**
 * Find nearby activity for an event
 * @param {Object} event - Event data
 * @param {number} radiusMeters - Radius in meters
 * @returns {Object} - Nearby activity counts
 */
function findNearbyActivity(event, radiusMeters = 500) {
    // Check if event has coordinates
    if (!event.lat || !event.lng) return null;
    
    const activity = {
        calls311: 0,
        transit: 0,
        taxi: 0
    };
    
    // Find nearby 311 calls
    if (all311Data && all311Data.length > 0) {
        activity.calls311 = all311Data.filter(call => {
            // Check if call is on the event date
            if (call.parsed_date !== formatDate(new Date(event.start_datetime))) return false;
            
            // Check if call has coordinates
            if (!call.lat || !call.lng) return false;
            
            // Calculate distance
            const distance = calculateDistance(
                event.lat, event.lng,
                call.lat, call.lng
            );
            
            return distance <= radiusMeters;
        }).length;
    }
    
    // Find nearby transit stations
    if (processedData.transit.stationRidership) {
        Object.values(processedData.transit.stationRidership).forEach(station => {
            if (!station.lat || !station.lng) return;
            
            // Calculate distance
            const distance = calculateDistance(
                event.lat, event.lng,
                station.lat, station.lng
            );
            
            if (distance <= radiusMeters) {
                // Add station ridership for event date
                const eventDate = formatDate(new Date(event.start_datetime));
                
                // Find hourly data for this station on event date
                transitData.forEach(entry => {
                    if (entry.parsed_date === eventDate && 
                        entry.station_complex_id === station.id) {
                        activity.transit += parseFloat(entry.ridership) || 0;
                    }
                });
            }
        });
    }
    
    // Find nearby taxi pickups
    if (taxiData && taxiData.length > 0) {
        // We don't have exact pickup coordinates, so use borough-level data
        const eventDate = formatDate(new Date(event.start_datetime));
        
        if (processedData.taxi.dailyData && processedData.taxi.dailyData[eventDate]) {
            activity.taxi = processedData.taxi.dailyData[eventDate].byBorough[event.borough] || 0;
        }
    }
    
    return activity;
}

/**
 * Generate event impact visualization
 * @param {Array} events - Events to visualize
 * @param {string} startDate - Start date
 * @param {string} endDate - End date
 * @returns {Object} - Visualization data
 */
function generateEventVisualization(events, startDate, endDate) {
    // Analyze event impact
    const impact = analyzeEventImpact(events, startDate, endDate);
    
    // Generate visualization data
    const visualization = {
        eventMarkers: [],
        impactAreas: [],
        stats: {
            totalEvents: impact.eventCount,
            significantImpact: impact.impact.length,
            byBorough: impact.byBorough,
            byType: impact.byType
        }
    };
    
    // Create markers for all events
    events.forEach(event => {
        if (!event.lat || !event.lng) return;
        
        // Format date for display
        const eventDate = new Date(event.start_datetime);
        const formattedDate = eventDate.toLocaleDateString();
        
        // Create marker data
        visualization.eventMarkers.push({
            lat: event.lat,
            lng: event.lng,
            name: event.event_name,
            date: formattedDate,
            borough: event.borough,
            type: event.event_type || 'Unknown',
            popup: `
                <div class="font-medium text-sm">${event.event_name}</div>
                <div class="text-xs">${formattedDate}</div>
                <div class="text-xs">${event.borough}</div>
                <div class="text-xs">${event.event_type || 'No type specified'}</div>
            `
        });
    });
    
    // Create impact areas for significant events
    impact.impact.forEach(event => {
        if (!event.lat || !event.lng) return;
        
        // Calculate overall impact score
        const impactScore = Math.max(
            Math.abs(event.percentChange || 0),
            Math.abs(event.transitChange || 0),
            Math.abs(event.taxiChange || 0)
        );
        
        // Scale radius based on impact score
        const radius = Math.min(500 + (impactScore * 10), 2000);
        
        // Create impact area data
        visualization.impactAreas.push({
            lat: event.lat,
            lng: event.lng,
            radius,
            event: event.event,
            date: event.date,
            borough: event.borough,
            callsChange: event.percentChange,
            transitChange: event.transitChange,
            taxiChange: event.taxiChange,
            color: impactScore > 50 ? '#EF4444' : (impactScore > 25 ? '#F59E0B' : '#10B981'),
            popup: `
                <div class="font-medium text-sm">${event.event}</div>
                <div class="text-xs">${event.date} - ${event.borough}</div>
                ${event.percentChange ? `<div class="text-xs">311 Calls: ${event.percentChange.toFixed(1)}%</div>` : ''}
                ${event.transitChange ? `<div class="text-xs">Transit: ${event.transitChange.toFixed(1)}%</div>` : ''}
                ${event.taxiChange ? `<div class="text-xs">Taxi: ${event.taxiChange.toFixed(1)}%</div>` : ''}
            `
        });
    });
    
    return visualization;
}

/**
 * Update event list display
 * @param {Array} events - Events to display
 */
function updateEventList(events) {
    const eventsList = document.getElementById('events-list');
    eventsList.innerHTML = '';
    
    if (!events || events.length === 0) {
        eventsList.innerHTML = '<p class="text-center p-4">No events found in the selected date range.</p>';
        return;
    }
    
    // Sort events by date
    const sortedEvents = [...events].sort((a, b) => new Date(a.start_datetime) - new Date(b.start_datetime));
    
    // Display top events
    sortedEvents.slice(0, 10).forEach(event => {
        const div = document.createElement('div');
        div.className = 'p-2 border-b';
        
        const startDate = new Date(event.start_datetime);
        const formattedDate = startDate.toLocaleDateString();
        
        div.innerHTML = `
            <div class="font-medium text-sm">${event.event_name}</div>
            <div class="text-xs flex justify-between mt-1">
                <span>${formattedDate}</span>
                <span class="font-medium">${event.borough}</span>
            </div>
        `;
        
        // Add click handler to show event on map
        div.addEventListener('click', () => {
            if (event.lat && event.lng) {
                // Switch to map tab
                document.getElementById('tab-map').click();
                
                // Fly to event location
                map.flyTo({
                    center: [event.lng, event.lat],
                    zoom: 14,
                    duration: 1000
                });
                
                // Create pulse effect
                createPulseEffect(map, [event.lng, event.lat], DATASET_COLORS.events);
            }
        });
        
        eventsList.appendChild(div);
    });
}

================================================================================

FILE: file_collection.txt
LINES: 4673
--------------------------------------------------------------------------------

CODE COLLECTION GENERATED ON 2025-04-29 14:14:53
Root directory: C:\Users\prath\Desktop\infoviz\project - Copy\final_front
================================================================================

FILE: charts.js
LINES: 1798
--------------------------------------------------------------------------------

/**
 * Chart creation and updates for NYC Urban Rhythm
 */

// Chart instances
let charts = {
    trends: null,
    dow: null,
    hour: null,
    proportion: null,
    categories: null,
    transitBorough: null,
    transitTime: null,
    taxiTime: null,
    taxiDistance: null,
    taxiLocations: null,
    eventsBorough: null,
    eventsType: null,
    transit311: null,
    eventsImpact: null,
    taxi311: null,
    correlationMatrix: null,
    temp: null,
    precip: null
};

/**
 * Initialize all charts
 */
function initializeCharts() {
    // Set Chart.js defaults
    Chart.defaults.font.family = "'Inter', sans-serif";
    Chart.defaults.font.size = 12;
    Chart.defaults.color = '#4B5563';
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    Chart.defaults.plugins.tooltip.titleColor = '#111827';
    Chart.defaults.plugins.tooltip.bodyColor = '#4B5563';
    Chart.defaults.plugins.tooltip.borderColor = '#E5E7EB';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.displayColors = true;
}

/**
 * Update all charts based on processed data
 */
function updateAllCharts() {
    updateTrendCharts();
    updateCategoryCharts();
    updateTransitCharts();
    updateTaxiCharts();
    updateEventCharts();
    updateCorrelationCharts();
    updateWeatherCharts();
}

/**
 * Update trend analysis charts
 */
function updateTrendCharts() {
    // Check if we have daily data
    if (!processedData.calls311.dailyData) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const days = Object.keys(processedData.calls311.dailyData).sort();
    
    // If too many days, sample to avoid overcrowding
    let displayDays = days;
    let displayData = processedData.calls311.dailyData;
    
    if (days.length > 14) {
        // Sample at most 14 days for clarity
        const sampleInterval = Math.max(1, Math.floor(days.length / 14));
        displayDays = days.filter((_, i) => i % sampleInterval === 0);
        
        // Filter data for sampled days
        displayData = {};
        displayDays.forEach(day => {
            displayData[day] = processedData.calls311.dailyData[day];
        });
    }
    
    // Daily trend chart
    const trendDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: displayDays.map(day => displayData[day].byBorough[borough] || 0),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        tension: 0.2
    }));
    
    if (charts.trends) charts.trends.destroy();
    charts.trends = new Chart(
        document.getElementById('trends-chart'),
        {
            type: 'line',
            data: {
                labels: displayDays,
                datasets: trendDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: '311 Calls Over Time',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Calls',
                            font: {
                                size: 10
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45,
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Day of week chart
    const dowLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const dowDatasets = [
        {
            label: '311 Calls',
            data: Array(7).fill(0),
            backgroundColor: DATASET_COLORS.calls311
        }
    ];
    
    // Add transit data if available
    if (processedData.transit.dowByBorough) {
        dowDatasets.push({
            label: 'Transit Entries',
            data: Array(7).fill(0),
            backgroundColor: DATASET_COLORS.transit
        });
    }
    
    // Add taxi data if available
    if (processedData.taxi.dowByBorough) {
        dowDatasets.push({
            label: 'Taxi Pickups',
            data: Array(7).fill(0),
            backgroundColor: DATASET_COLORS.taxi
        });
    }
    
    // Aggregate calls by day of week
    validBoroughs.forEach(borough => {
        if (processedData.calls311.dowByBorough) {
            processedData.calls311.dowByBorough[borough].forEach((count, dow) => {
                dowDatasets[0].data[dow] += count;
            });
        }
        
        // Add transit data if available
        if (processedData.transit.dowByBorough && dowDatasets.length > 1) {
            processedData.transit.dowByBorough[borough].forEach((count, dow) => {
                dowDatasets[1].data[dow] += count * 0.1; // Scale down transit data
            });
        }
        
        // Add taxi data if available
        if (processedData.taxi.dowByBorough && dowDatasets.length > 2) {
            processedData.taxi.dowByBorough[borough].forEach((count, dow) => {
                dowDatasets[2].data[dow] += count;
            });
        }
    });
    
    if (charts.dow) charts.dow.destroy();
    charts.dow = new Chart(
        document.getElementById('dow-chart'),
        {
            type: 'bar',
            data: {
                labels: dowLabels,
                datasets: dowDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Activity by Day of Week',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Activity Count',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Hour of day chart
    const hourLabels = Array(24).fill().map((_, i) => i);
    const hourDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: processedData.calls311.hourlyByBorough[borough],
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.hour) charts.hour.destroy();
    charts.hour = new Chart(
        document.getElementById('hour-chart'),
        {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: hourDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: '311 Calls by Hour of Day',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Calls',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            stepSize: 2,
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                return `${value}:00`;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Borough proportion over time
    const proportionDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: displayDays.map(day => {
            const total = displayData[day].total;
            return total > 0 ? (displayData[day].byBorough[borough] / total) * 100 : 0;
        }),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.proportion) charts.proportion.destroy();
    charts.proportion = new Chart(
        document.getElementById('proportion-chart'),
        {
            type: 'line',
            data: {
                labels: displayDays,
                datasets: proportionDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Borough Proportion Over Time',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Percentage of Daily Calls',
                            font: {
                                size: 10
                            }
                        },
                        min: 0,
                        max: 100,
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45,
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update category charts
 */
function updateCategoryCharts() {
    // Check if we have complaint types data
    if (!processedData.calls311.complaintTypes) return;
    
    // Populate categories list
    const categoriesList = document.getElementById('categories-list');
    categoriesList.innerHTML = '';
    
    // Get sorted complaints
    const sortedComplaints = Object.entries(processedData.calls311.complaintTypes)
        .sort((a, b) => b[1].total - a[1].total);
    
    // Create list items for top 20 complaints
    sortedComplaints.slice(0, 20).forEach(([complaint, data]) => {
        const div = document.createElement('div');
        div.className = 'category-item p-2 border-b flex justify-between items-center';
        
        div.innerHTML = `
            <span class="complaint-name">${complaint}</span>
            <span class="text-gray-700 font-medium">${formatNumber(data.total)}</span>
        `;
        
        div.addEventListener('click', () => {
            // Update selected state
            document.querySelectorAll('.category-item').forEach(el => 
                el.classList.remove('selected')
            );
            div.classList.add('selected');
            
            // Update category chart
            updateCategoryChart(complaint, data);
        });
        
        categoriesList.appendChild(div);
    });
    
    // Select first category by default
    if (sortedComplaints.length > 0) {
        const [firstComplaint, firstData] = sortedComplaints[0];
        document.querySelector('.category-item')?.classList.add('selected');
        updateCategoryChart(firstComplaint, firstData);
    }
}

/**
 * Update category breakdown chart
 * @param {string} complaint - Complaint type
 * @param {Object} data - Complaint data
 */
function updateCategoryChart(complaint, data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    if (charts.categories) charts.categories.destroy();
    charts.categories = new Chart(
        document.getElementById('categories-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: complaint,
                    data: validBoroughs.map(borough => data.byBorough[borough] || 0),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: complaint.length > 40 ? complaint.substring(0, 40) + '...' : complaint,
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Complaints',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update transit charts
 */
function updateTransitCharts() {
    // Check if we have transit data
    if (!processedData.transit.ridershipByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Transit by borough chart
    if (charts.transitBorough) charts.transitBorough.destroy();
    charts.transitBorough = new Chart(
        document.getElementById('transit-borough-chart'),
        {
            type: 'pie',
            data: {
                labels: validBoroughs,
                datasets: [{
                    data: validBoroughs.map(borough => 
                        processedData.transit.ridershipByBorough[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ridership by Borough',
                        font: {
                            size: 14
                        }
                    }
                }
            }
        }
    );
    
    // Transit by time of day chart
    const hourLabels = Array(24).fill().map((_, i) => i);
    const timeDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: processedData.transit.hourlyByBorough?.[borough] || Array(24).fill(0),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.transitTime) charts.transitTime.destroy();
    charts.transitTime = new Chart(
        document.getElementById('transit-time-chart'),
        {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: timeDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ridership by Hour of Day',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Entries',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            stepSize: 2,
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                return `${value}:00`;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Top stations list
    const topStations = document.getElementById('top-stations');
    topStations.innerHTML = '';
    
    // Get sorted stations
    const sortedStations = Object.entries(processedData.transit.stationRidership || {})
        .sort((a, b) => b[1].total - a[1].total);
    
    // Create list items for top stations
    sortedStations.slice(0, 9).forEach(([station, data]) => {
        const div = document.createElement('div');
        div.className = 'p-2 bg-gray-50 rounded-lg text-xs';
        
        div.innerHTML = `
            <div class="font-medium">${station}</div>
            <div class="text-gray-600">${data.borough}</div>
            <div class="font-medium text-green-800 mt-1">${formatNumber(Math.round(data.total))} entries</div>
        `;
        
        topStations.appendChild(div);
    });
}

/**
 * Update taxi charts
 */
function updateTaxiCharts() {
    // Check if we have taxi data
    if (!processedData.taxi.pickupsByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Trip volume by time chart
    const hourLabels = Array(24).fill().map((_, i) => i);
    const timeDatasets = validBoroughs.map(borough => ({
        label: borough,
        data: processedData.taxi.hourlyByBorough?.[borough] || Array(24).fill(0),
        borderColor: BOROUGH_COLORS[borough],
        backgroundColor: BOROUGH_COLORS[borough] + '40',
        pointRadius: 1,
    }));
    
    if (charts.taxiTime) charts.taxiTime.destroy();
    charts.taxiTime = new Chart(
        document.getElementById('taxi-time-chart'),
        {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: timeDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Trip Volume by Hour of Day',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Pickups',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            stepSize: 2,
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                return `${value}:00`;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Average trip distance chart
    if (charts.taxiDistance) charts.taxiDistance.destroy();
    charts.taxiDistance = new Chart(
        document.getElementById('taxi-distance-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: 'Average Trip Distance (miles)',
                    data: validBoroughs.map(borough => 
                        processedData.taxi.metrics?.distanceByBorough?.[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Average Trip Distance by Borough',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Miles',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Popular pickup/dropoff zones chart
    const pickupData = validBoroughs.map(borough => 
        processedData.taxi.pickupsByBorough[borough] || 0
    );
    
    const dropoffData = validBoroughs.map(borough => 
        processedData.taxi.dropoffsByBorough[borough] || 0
    );
    
    if (charts.taxiLocations) charts.taxiLocations.destroy();
    charts.taxiLocations = new Chart(
        document.getElementById('taxi-locations-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [
                    {
                        label: 'Pickups',
                        data: pickupData,
                        backgroundColor: '#F59E0B',
                    },
                    {
                        label: 'Dropoffs',
                        data: dropoffData,
                        backgroundColor: '#60A5FA',
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Pickup vs Dropoff Locations',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Trips',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update event charts
 */
function updateEventCharts() {
    // Check if we have events data
    if (!processedData.events.eventsByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Events by borough chart
    if (charts.eventsBorough) charts.eventsBorough.destroy();
    charts.eventsBorough = new Chart(
        document.getElementById('events-borough-chart'),
        {
            type: 'pie',
            data: {
                labels: validBoroughs,
                datasets: [{
                    data: validBoroughs.map(borough => 
                        processedData.events.eventsByBorough[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => BOROUGH_COLORS[borough]),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 10
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Events by Borough',
                        font: {
                            size: 14
                        }
                    }
                }
            }
        }
    );
    
    // Events by type chart
    if (!processedData.events.eventTypes) return;
    
    // Get top event types
    const sortedTypes = Object.entries(processedData.events.eventTypes)
        .sort((a, b) => b[1].total - a[1].total)
        .slice(0, 5);
    
    if (charts.eventsType) charts.eventsType.destroy();
    charts.eventsType = new Chart(
        document.getElementById('events-type-chart'),
        {
            type: 'bar',
            data: {
                labels: sortedTypes.map(([type]) => type),
                datasets: [{
                    label: 'Number of Events',
                    data: sortedTypes.map(([_, data]) => data.total),
                    backgroundColor: sortedTypes.map((_, i) => 
                        `hsl(${270 + (i * 20)}, 70%, 60%)`
                    ),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Top Event Types',
                        font: {
                            size: 14
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Events',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: {
                                size: 9
                            },
                            callback: function(value) {
                                const label = this.getLabelForValue(value);
                                return label.length > 15 ? label.substring(0, 15) + '...' : label;
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Upcoming/recent events list
    const eventsList = document.getElementById('events-list');
    eventsList.innerHTML = '';
    
    // Get sorted events by date
    const sortedEvents = [...(processedData.events.eventsList || [])]
        .sort((a, b) => new Date(a.start) - new Date(b.start));
    
    // Create list items for events
    sortedEvents.slice(0, 10).forEach(event => {
        const div = document.createElement('div');
        div.className = 'p-2 border-b';
        
        const startDate = new Date(event.start);
        const formattedDate = startDate.toLocaleDateString();
        
        div.innerHTML = `
            <div class="font-medium text-sm">${event.name}</div>
            <div class="text-xs flex justify-between mt-1">
                <span>${formattedDate}</span>
                <span class="font-medium">${event.borough}</span>
            </div>
        `;
        
        eventsList.appendChild(div);
    });
}

/**
 * Update correlation charts
 */
function updateCorrelationCharts() {
    // Calculate correlations
    const correlations = calculateDatasetCorrelations();
    
    // Transit vs 311 correlation chart
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    if (charts.transit311) charts.transit311.destroy();
    charts.transit311 = new Chart(
        document.getElementById('transit-311-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: 'Correlation Coefficient',
                    data: validBoroughs.map(borough => 
                        correlations.transitVs311[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => {
                        const corr = correlations.transitVs311[borough] || 0;
                        return corr >= 0 ? '#10B981' : '#EF4444';
                    }),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Transit & 311 Call Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Taxi vs 311 correlation chart
    if (charts.taxi311) charts.taxi311.destroy();
    charts.taxi311 = new Chart(
        document.getElementById('taxi-311-chart'),
        {
            type: 'bar',
            data: {
                labels: validBoroughs,
                datasets: [{
                    label: 'Correlation Coefficient',
                    data: validBoroughs.map(borough => 
                        correlations.taxiVs311[borough] || 0
                    ),
                    backgroundColor: validBoroughs.map(borough => {
                        const corr = correlations.taxiVs311[borough] || 0;
                        return corr >= 0 ? '#F59E0B' : '#EF4444';
                    }),
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Taxi & 311 Call Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
    
    // Events impact chart
    if (correlations.eventsImpact && correlations.eventsImpact.length > 0) {
        const impactEvents = correlations.eventsImpact.slice(0, 5);
        
        if (charts.eventsImpact) charts.eventsImpact.destroy();
        charts.eventsImpact = new Chart(
            document.getElementById('events-impact-chart'),
            {
                type: 'bar',
                data: {
                    labels: impactEvents.map(event => event.event.length > 15 ? 
                        event.event.substring(0, 15) + '...' : event.event
                    ),
                    datasets: [{
                        label: 'Percent Change in 311 Calls',
                        data: impactEvents.map(event => event.percentChange),
                        backgroundColor: impactEvents.map(event => 
                            event.percentChange >= 0 ? '#8B5CF6' : '#EF4444'
                        ),
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Events Impact on 311 Calls',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return `Change: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Percent Change',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        },
                        y: {
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Correlation matrix
    const datasets = ['calls311', 'transit', 'taxi', 'events'];
    const matrix = [];
    
    // Calculate all pair-wise correlations
    for (let i = 0; i < datasets.length; i++) {
        matrix.push([]);
        
        for (let j = 0; j < datasets.length; j++) {
            if (i === j) {
                // Perfect correlation with self
                matrix[i].push(1);
            } else {
                // Calculate average borough correlation
                let sum = 0, count = 0;
                
                validBoroughs.forEach(borough => {
                    if (datasets[i] === 'calls311' && datasets[j] === 'transit') {
                        if (correlations.transitVs311 && correlations.transitVs311[borough] !== undefined) {
                            sum += correlations.transitVs311[borough];
                            count++;
                        }
                    } else if (datasets[i] === 'transit' && datasets[j] === 'calls311') {
                        if (correlations.transitVs311 && correlations.transitVs311[borough] !== undefined) {
                            sum += correlations.transitVs311[borough];
                            count++;
                        }
                    } else if (datasets[i] === 'calls311' && datasets[j] === 'taxi') {
                        if (correlations.taxiVs311 && correlations.taxiVs311[borough] !== undefined) {
                            sum += correlations.taxiVs311[borough];
                            count++;
                        }
                    } else if (datasets[i] === 'taxi' && datasets[j] === 'calls311') {
                        if (correlations.taxiVs311 && correlations.taxiVs311[borough] !== undefined) {
                            sum += correlations.taxiVs311[borough];
                            count++;
                        }
                    } else {
                        // For other combinations, use a default low correlation
                        sum += 0.1;
                        count++;
                    }
                });
                
                matrix[i].push(count > 0 ? sum / count : 0);
            }
        }
    }
    
    if (charts.correlationMatrix) charts.correlationMatrix.destroy();   
    charts.correlationMatrix = new Chart(
        document.getElementById('correlation-matrix'),
        {
            type: 'heatmap',
            data: {
                labels: ['311 Calls', 'Transit', 'Taxi', 'Events'],
                datasets: [{
                    label: 'Correlation',
                    data: matrix.flat(),
                    width: 4,
                    height: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Dataset Correlation Matrix',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',
                        labels: ['311 Calls', 'Transit', 'Taxi', 'Events'],
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    y: {
                        type: 'category',
                        labels: ['311 Calls', 'Transit', 'Taxi', 'Events'],
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update weather correlation charts
 */
function updateWeatherCharts() {
    // Check if we have weather data
    if (Object.keys(processedData.weather).length === 0) {
        document.getElementById('weather-findings').innerHTML = 
            '<p class="text-center p-4">Weather data not available. Please update dashboard first.</p>';
        
        // Clear charts if they exist
        if (charts.temp) {
            charts.temp.destroy();
            charts.temp = null;
        }
        if (charts.precip) {
            charts.precip.destroy();
            charts.precip = null;
        }
        return;
    }
    
    // Prepare temp vs call data
    const tempData = [];
    const precipData = [];
    
    Object.entries(processedData.weather).forEach(([date, data]) => {
        if (data.tmax !== null && processedData.calls311.dailyData && processedData.calls311.dailyData[date]) {
            tempData.push({
                x: data.tmax,
                y: processedData.calls311.dailyData[date].total,
                date: date
            });
        }
        
        if (data.prcp !== null && processedData.calls311.dailyData && processedData.calls311.dailyData[date]) {
            precipData.push({
                x: data.prcp,
                y: processedData.calls311.dailyData[date].total,
                date: date
            });
        }
    });
    
    // Temperature correlation chart
    if (charts.temp) charts.temp.destroy();
    
    if (tempData.length === 0) {
        // Handle empty temperature data
        document.getElementById('temp-correlation').getContext('2d').clearRect(
            0, 0, 
            document.getElementById('temp-correlation').width, 
            document.getElementById('temp-correlation').height
        );
    } else {
        charts.temp = new Chart(
            document.getElementById('temp-correlation'),
            {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Daily Calls vs Max Temp',
                        data: tempData,
                        backgroundColor: '#3B82F6',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Temperature vs. 311 Call Volume',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return `Date: ${point.date}, Temp: ${point.x}°F, Calls: ${point.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of 311 Calls',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Maximum Temperature (°F)',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Precipitation correlation chart
    if (charts.precip) charts.precip.destroy();
    
    if (precipData.length === 0) {
        // Handle empty precipitation data
        document.getElementById('precip-correlation').getContext('2d').clearRect(
            0, 0, 
            document.getElementById('precip-correlation').width, 
            document.getElementById('precip-correlation').height
        );
    } else {
        charts.precip = new Chart(
            document.getElementById('precip-correlation'),
            {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Daily Calls vs Precipitation',
                        data: precipData,
                        backgroundColor: '#10B981',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Precipitation vs. 311 Call Volume',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return `Date: ${point.date}, Precip: ${point.x} in, Calls: ${point.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of 311 Calls',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Precipitation (inches)',
                                font: {
                                    size: 10
                                }
                            },
                            ticks: {
                                font: {
                                    size: 9
                                }
                            }
                        }
                    }
                }
            }
        );
    }
    
    // Weather findings analysis
    updateWeatherFindings();
}

/**
 * Update weather findings analysis
 */
function updateWeatherFindings() {
    const weatherFindings = document.getElementById('weather-findings');
    
    // Analyze weather-sensitive complaints
    if (!processedData.calls311.complaintTypes || Object.keys(processedData.weather).length === 0) {
        weatherFindings.innerHTML = '<p class="text-center p-4">Insufficient data to determine weather correlations.</p>';
        return;
    }
    
    // Group complaints by temperature ranges
    const tempRanges = [
        { name: 'Cold', min: -20, max: 40 },
        { name: 'Cool', min: 40, max: 60 },
        { name: 'Mild', min: 60, max: 75 },
        { name: 'Warm', min: 75, max: 85 },
        { name: 'Hot', min: 85, max: 110 }
    ];
    
    const complaintsTemp = {};
    const complaintsPrec = { 'Rainy': {}, 'Dry': {} };
    
    // Analyze by temperature
    Object.entries(processedData.weather).forEach(([date, weather]) => {
        if (!processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
        
        // Process by temperature
        if (weather.tmax !== null) {
            const range = tempRanges.find(r => weather.tmax >= r.min && weather.tmax < r.max);
            if (!range) return;
            
            // Get complaints for this day
            const complaints = {};
            
            // Filter 311 data for this date
            all311Data.forEach(call => {
                if (call.parsed_date === date) {
                    if (!complaints[call.complaint]) complaints[call.complaint] = 0;
                    complaints[call.complaint]++;
                }
            });
            
            // Aggregate by temperature range
            Object.entries(complaints).forEach(([complaint, count]) => {
                if (!complaintsTemp[complaint]) {
                    complaintsTemp[complaint] = tempRanges.reduce((acc, r) => {
                        acc[r.name] = { count: 0, days: 0 };
                        return acc;
                    }, {});
                }
                
                complaintsTemp[complaint][range.name].count += count;
                complaintsTemp[complaint][range.name].days += 1;
            });
        }
        
        // Process by precipitation
        if (weather.prcp !== null) {
            const isRainy = weather.prcp > 0.1;
            const category = isRainy ? 'Rainy' : 'Dry';
            
            // Filter 311 data for this date
            all311Data.forEach(call => {
                if (call.parsed_date === date) {
                    if (!complaintsPrec[category][call.complaint]) {
                        complaintsPrec[category][call.complaint] = 0;
                    }
                    complaintsPrec[category][call.complaint]++;
                }
            });
        }
    });
    
    // Find temperature-sensitive complaints
    const tempSensitive = Object.entries(complaintsTemp)
        .map(([complaint, ranges]) => {
            // Calculate frequencies
            const frequencies = Object.entries(ranges).map(([range, data]) => {
                return { range, freq: data.days > 0 ? data.count / data.days : 0 };
            });
            
            // Find min and max frequency
            const freqValues = frequencies.map(f => f.freq);
            const minFreq = Math.min(...freqValues);
            const maxFreq = Math.max(...freqValues);
            
            // Calculate spread
            const spread = minFreq > 0 ? maxFreq / minFreq : 0;
            
            return {
                complaint,
                spread,
                frequencies
            };
        })
        .filter(c => c.spread > 1.5 && c.frequencies.some(f => f.freq > 5))
        .sort((a, b) => b.spread - a.spread)
        .slice(0, 5);
    
    // Find precipitation-sensitive complaints
    const precipSensitive = [];
    
    Object.keys(complaintsPrec.Rainy).forEach(complaint => {
        if (complaintsPrec.Dry[complaint]) {
            const rainyCount = complaintsPrec.Rainy[complaint];
            const dryCount = complaintsPrec.Dry[complaint];
            
            // Count rainy and dry days
            const rainyDays = Object.values(processedData.weather)
                .filter(data => data.prcp !== null && data.prcp > 0.1)
                .length;
                
            const dryDays = Object.values(processedData.weather)
                .filter(data => data.prcp !== null && data.prcp <= 0.1)
                .length;
            
            // Calculate rates
            const rainyRate = rainyDays > 0 ? rainyCount / rainyDays : 0;
            const dryRate = dryDays > 0 ? dryCount / dryDays : 0;
            
            // Calculate ratio
            const ratio = Math.max(rainyRate, dryRate) / Math.max(0.1, Math.min(rainyRate, dryRate));
            const diff = Math.abs(rainyRate - dryRate);
            
            if (ratio > 1.3 && diff > 1) {
                precipSensitive.push({
                    complaint,
                    rainyRate,
                    dryRate,
                    ratio,
                    more: rainyRate > dryRate ? 'rainy' : 'dry'
                });
            }
        }
    });
    
    // Sort by ratio
    precipSensitive.sort((a, b) => b.ratio - a.ratio);
    
    // Create HTML output
    let html = '<div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-xs">';
    
    // Temperature findings
    html += '<div>';
    html += '<h4 class="font-medium mb-1">Temperature-Sensitive Complaints:</h4>';
    if (tempSensitive.length === 0) {
        html += '<p>Insufficient data to determine temperature correlation.</p>';
    } else {
        html += '<ul class="list-disc pl-4">';
        tempSensitive.forEach(item => {
            const maxFreq = Math.max(...item.frequencies.map(f => f.freq));
            const maxRange = item.frequencies.find(f => f.freq === maxFreq).range;
            
            html += `<li><span class="font-medium">${item.complaint}</span>: ${Math.round(item.spread * 10) / 10}x more frequent during <span class="font-medium">${maxRange}</span> weather</li>`;
        });
        html += '</ul>';
    }
    html += '</div>';
    
    // Precipitation findings
    html += '<div>';
    html += '<h4 class="font-medium mb-1">Precipitation-Sensitive Complaints:</h4>';
    if (precipSensitive.length === 0) {
        html += '<p>Insufficient data to determine precipitation correlation.</p>';
    } else {
        html += '<ul class="list-disc pl-4">';
        precipSensitive.slice(0, 5).forEach(item => {
            html += `<li><span class="font-medium">${item.complaint}</span>: ${Math.round(item.ratio * 10) / 10}x more frequent during <span class="font-medium">${item.more}</span> days</li>`;
        });
        html += '</ul>';
    }
    html += '</div>';
    
    html += '</div>';
    
    weatherFindings.innerHTML = html;
}

================================================================================

FILE: collector.py
LINES: 129
--------------------------------------------------------------------------------

#!/usr/bin/env python3
"""
File Collector Script

This script recursively searches through directories starting from the current directory,
finds all files (excluding specified binary/media formats), and collects their content into 
a single text file with file paths and separators for better readability.
"""

import os
import argparse
from datetime import datetime


def collect_code(root_dir='.', output_file='code_collection.txt', exclude_extensions=None, ignore_dirs=None):
    """
    Recursively collect all files into a single text file.
    
    Args:
        root_dir (str): Root directory to start the search from
        output_file (str): Name of the output file
        exclude_extensions (list): List of file extensions to exclude (e.g., ['.pyc', '.exe'])
        ignore_dirs (list): List of directory names to ignore (e.g., ['node_modules', '.git'])
    """
    if exclude_extensions is None:
        # Default extensions to exclude - typically binary or temporary files
        exclude_extensions = [
            '.pyc', '.pyo', '.pyd', '.exe', '.dll', '.so', '.o', '.obj',
            '.class', '.jar', '.war', '.ear', '.zip', '.tar', '.gz', '.7z',
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg', '.mp3',
            '.mp4', '.avi', '.mov', '.flv', '.wmv', '.pdf', '.doc', '.docx',
            '.xls', '.xlsx', '.ppt', '.pptx'
        ]
    
    if ignore_dirs is None:
        # Default directories to ignore - add or remove based on your needs
        ignore_dirs = ['.git', 'node_modules', 'venv', '__pycache__', 'dist', 'build']
    
    # Convert exclude_extensions to lowercase for case-insensitive matching
    exclude_extensions = [ext.lower() for ext in exclude_extensions]
    
    # Get absolute path of root directory
    root_dir = os.path.abspath(root_dir)
    
    print(f"Starting code collection from {root_dir}")
    print(f"Excluding extensions: {', '.join(exclude_extensions)}")
    print(f"Ignoring directories: {', '.join(ignore_dirs)}")
    
    # Total counters
    total_files = 0
    total_lines = 0
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Write header
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        outfile.write(f"CODE COLLECTION GENERATED ON {timestamp}\n")
        outfile.write(f"Root directory: {root_dir}\n")
        outfile.write("=" * 80 + "\n\n")
        
        # Walk through directory tree
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Remove ignored directories from dirnames to prevent walking into them
            # Using slice assignment to modify dirnames in-place (required by os.walk)
            dirnames[:] = [d for d in dirnames if d not in ignore_dirs]
            
            for filename in filenames:
                # Check if the file does not have one of the excluded extensions
                file_ext = os.path.splitext(filename)[1].lower()
                if file_ext not in exclude_extensions:
                    file_path = os.path.join(dirpath, filename)
                    rel_path = os.path.relpath(file_path, root_dir)
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                            
                            # Count lines
                            line_count = content.count('\n') + (0 if content.endswith('\n') else 1)
                            total_lines += line_count
                            total_files += 1
                            
                            # Write file info and content to output file
                            outfile.write(f"FILE: {rel_path}\n")
                            outfile.write(f"LINES: {line_count}\n")
                            outfile.write("-" * 80 + "\n\n")
                            outfile.write(content)
                            outfile.write("\n\n")
                            outfile.write("=" * 80 + "\n\n")
                            
                            print(f"Added: {rel_path} ({line_count} lines)")
                    except Exception as e:
                        print(f"Error reading {rel_path}: {e}")
    
    # Write summary at the end of the file
    with open(output_file, 'a', encoding='utf-8') as outfile:
        outfile.write(f"\nSUMMARY\n")
        outfile.write(f"Total files processed: {total_files}\n")
        outfile.write(f"Total lines of code: {total_lines}\n")
    
    print(f"\nCollection complete!")
    print(f"Processed {total_files} files with {total_lines} lines of code")
    print(f"Output saved to: {os.path.abspath(output_file)}")


def main():
    """Parse command line arguments and run the script."""
    parser = argparse.ArgumentParser(description='Collect all files into a single text file.')
    parser.add_argument('-d', '--directory', default='.', help='Root directory to start from (default: current directory)')
    parser.add_argument('-o', '--output', default='file_collection.txt', help='Output file name (default: file_collection.txt)')
    parser.add_argument('-e', '--exclude', nargs='+', help='File extensions to exclude (e.g., .exe .jpg)')
    parser.add_argument('-i', '--ignore', nargs='+', help='Directories to ignore (e.g., node_modules .git)')
    
    args = parser.parse_args()
    
    # Convert exclude extensions from command line to proper format with leading dot
    exclude_extensions = None
    if args.exclude:
        exclude_extensions = [ext if ext.startswith('.') else f'.{ext}' for ext in args.exclude]
    
    collect_code(
        root_dir=args.directory,
        output_file=args.output,
        exclude_extensions=exclude_extensions,
        ignore_dirs=args.ignore
    )


if __name__ == "__main__":
    main()

================================================================================

FILE: config.js
LINES: 140
--------------------------------------------------------------------------------

// Configuration settings for NYC Urban Rhythm

// Mapbox access token
const MAPBOX_ACCESS_TOKEN = 'pk.eyJ1IjoicHJhdGhhbXNhcmFmMDA3IiwiYSI6ImNtOXljeWExajFlOTYyanBzdmh2YXplNXMifQ.UCm1kg1UeqCrz0j16fpQtA';

// NYC Borough configurations
const BOROUGH_CENTROIDS = {
    Manhattan: [40.7831, -73.9712],
    Brooklyn: [40.6782, -73.9442],
    Bronx: [40.8448, -73.8648],
    Queens: [40.7282, -73.7949],
    'Staten Island': [40.5795, -74.1502]
};

// Color schemes for boroughs
const BOROUGH_COLORS = {
    Manhattan: '#3182CE',
    Brooklyn: '#F59E0B',
    Bronx: '#10B981',
    Queens: '#6366F1', 
    'Staten Island': '#EC4899'
};

// Weather station mapping
const WEATHER_STATIONS = {
    Manhattan: 'USW00094728',
    Brooklyn: 'USW00094777',
    Bronx: 'USW00014727',
    Queens: 'USW00014734',
    'Staten Island': 'USW00014736'
};

// Dataset color coding
const DATASET_COLORS = {
    calls311: '#3B82F6',
    transit: '#10B981',
    taxi: '#F59E0B',
    events: '#8B5CF6',
    weather: '#A855F7'
};

// NYC Geojson source
const GEOJSON_URL = 'https://raw.githubusercontent.com/codeforgermany/click_that_hood/main/public/data/new-york-city-boroughs.geojson';

// API endpoints
const API_CONFIG = {
    weatherProxy: 'http://localhost:3000/noaa',
    geocodingEndpoint: 'https://api.mapbox.com/geocoding/v5/mapbox.places/'
};

// Default temporal aggregation settings
const TIME_AGGREGATION = {
    hourly: {
        format: 'HH:mm',
        labelFormat: 'ha',
        buckets: 24
    },
    daily: {
        format: 'YYYY-MM-DD',
        labelFormat: 'MMM D',
        buckets: 31
    },
    weekly: {
        format: 'YYYY-[W]WW',
        labelFormat: 'MMM D',
        buckets: 52
    },
    monthly: {
        format: 'YYYY-MM',
        labelFormat: 'MMM YYYY',
        buckets: 12
    }
};

// Chart configuration defaults
const CHART_DEFAULTS = {
    responsive: true,
    maintainAspectRatio: false,
    animation: {
        duration: 1000
    },
    scales: {
        y: {
            beginAtZero: true,
            ticks: {
                font: { size: 10 }
            }
        },
        x: {
            ticks: {
                font: { size: 10 }
            }
        }
    },
    plugins: {
        legend: {
            position: 'top',
            labels: {
                boxWidth: 12,
                font: { size: 10 }
            }
        },
        tooltip: {
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            titleColor: '#333',
            bodyColor: '#333',
            borderColor: '#ddd',
            borderWidth: 1,
            padding: 10,
            displayColors: true,
            titleFont: { size: 12, weight: 'bold' },
            bodyFont: { size: 11 }
        }
    }
};

// Zone ID to borough mapping for TLC data
const ZONE_TO_BOROUGH = {
    // Manhattan (1-143)
    1: 'Manhattan', 2: 'Manhattan', 3: 'Manhattan', 4: 'Manhattan', 5: 'Manhattan',
    6: 'Manhattan', 7: 'Manhattan', 8: 'Manhattan', 9: 'Manhattan', 10: 'Manhattan',
    11: 'Manhattan', 12: 'Manhattan', 13: 'Manhattan', 14: 'Manhattan', 15: 'Manhattan',
    // ... add more as needed for your dataset
    
    // Bronx (144-200)
    144: 'Bronx', 145: 'Bronx', 146: 'Bronx', 147: 'Bronx', 148: 'Bronx',
    // ... add more as needed
    
    // Brooklyn (201-263)
    201: 'Brooklyn', 202: 'Brooklyn', 203: 'Brooklyn', 204: 'Brooklyn', 205: 'Brooklyn',
    // ... add more as needed
    
    // Queens (264-324)
    264: 'Queens', 265: 'Queens', 266: 'Queens', 267: 'Queens', 268: 'Queens',
    // ... add more as needed
    
    // Staten Island (325-344)
    325: 'Staten Island', 326: 'Staten Island', 327: 'Staten Island', 328: 'Staten Island',
    // ... add more as needed
};

================================================================================

FILE: correlationDashboard.js
LINES: 704
--------------------------------------------------------------------------------

/**
 * Cross-dataset correlation analysis and dashboard for NYC Urban Rhythm
 */

/**
 * Calculate correlations between all datasets
 * @param {Object} processedData - Processed data from all datasets
 * @returns {Object} - Correlation matrix and insights
 */
function calculateAllCorrelations() {
    // Initialize correlation object
    const correlations = {
        matrix: {},
        insights: [],
        hotspots: []
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Datasets to analyze
    const datasets = ['calls311', 'transit', 'taxi', 'events'];
    
    // Initialize correlation matrix
    datasets.forEach(d1 => {
        correlations.matrix[d1] = {};
        datasets.forEach(d2 => {
            correlations.matrix[d1][d2] = d1 === d2 ? 1 : null;
        });
    });
    
    // Calculate correlations between datasets
    
    // 1. Transit vs 311
    const transit311 = calculateTransit311Correlation();
    if (transit311) {
        // Set matrix values
        correlations.matrix['transit']['calls311'] = 
        correlations.matrix['calls311']['transit'] = 
            Object.values(transit311.byBorough).reduce((sum, val) => sum + val, 0) / 
            Object.values(transit311.byBorough).length;
        
        // Add borough-level insights
        validBoroughs.forEach(borough => {
            if (transit311.byBorough[borough] !== undefined) {
                const corr = transit311.byBorough[borough];
                if (Math.abs(corr) > 0.5) {
                    correlations.insights.push({
                        type: 'transit-311',
                        borough,
                        correlation: corr,
                        description: `${borough} shows a ${corr > 0 ? 'positive' : 'negative'} correlation (${corr.toFixed(2)}) between transit ridership and 311 calls`
                    });
                }
            }
        });
    }
    
    // 2. Taxi vs 311
    const taxi311 = analyzeTaxi311Correlation();
    if (taxi311) {
        // Set matrix values
        correlations.matrix['taxi']['calls311'] = 
        correlations.matrix['calls311']['taxi'] = 
            Object.values(taxi311.byBorough).reduce((sum, val) => sum + val, 0) / 
            Object.values(taxi311.byBorough).length;
        
        // Add borough-level insights
        validBoroughs.forEach(borough => {
            if (taxi311.byBorough[borough] !== undefined) {
                const corr = taxi311.byBorough[borough];
                if (Math.abs(corr) > 0.5) {
                    correlations.insights.push({
                        type: 'taxi-311',
                        borough,
                        correlation: corr,
                        description: `${borough} shows a ${corr > 0 ? 'positive' : 'negative'} correlation (${corr.toFixed(2)}) between taxi activity and 311 calls`
                    });
                }
            }
        });
    }
    
    // 3. Events impact on other datasets
    if (processedData.events.eventsList && processedData.events.eventsList.length > 0) {
        // Analyze event impact
        const eventAnalysis = analyzeEventImpact(
            processedData.events.eventsList,
            document.getElementById('startDate').value,
            document.getElementById('endDate').value
        );
        
        if (eventAnalysis.impact && eventAnalysis.impact.length > 0) {
            // Calculate average impact
            const avgImpact = eventAnalysis.impact.reduce((sum, event) => {
                return sum + Math.abs(event.percentChange || 0);
            }, 0) / eventAnalysis.impact.length;
            
            // Set matrix value based on impact magnitude
            correlations.matrix['events']['calls311'] = 
            correlations.matrix['calls311']['events'] = 
                avgImpact > 50 ? 0.8 : avgImpact > 30 ? 0.6 : avgImpact > 15 ? 0.4 : 0.2;
            
            // Add insights for significant impacts
            eventAnalysis.impact.slice(0, 3).forEach(impact => {
                if (Math.abs(impact.percentChange || 0) > 20) {
                    correlations.insights.push({
                        type: 'event-impact',
                        event: impact.event,
                        borough: impact.borough,
                        change: impact.percentChange,
                        description: `Event "${impact.event}" in ${impact.borough} caused a ${impact.percentChange.toFixed(1)}% change in 311 calls`
                    });
                }
            });
        }
    }
    
    // 4. Transit vs Taxi
    // Use hourly patterns to calculate correlation
    if (processedData.transit.hourlyByBorough && processedData.taxi.hourlyByBorough) {
        const transitHourly = Array(24).fill(0);
        const taxiHourly = Array(24).fill(0);
        
        validBoroughs.forEach(borough => {
            for (let hour = 0; hour < 24; hour++) {
                transitHourly[hour] += processedData.transit.hourlyByBorough[borough][hour] || 0;
                taxiHourly[hour] += processedData.taxi.hourlyByBorough[borough][hour] || 0;
            }
        });
        
        // Calculate correlation
        const transitTaxiCorr = calculateCorrelation(transitHourly, taxiHourly);
        
        // Set matrix values
        correlations.matrix['transit']['taxi'] = 
        correlations.matrix['taxi']['transit'] = transitTaxiCorr;
        
        if (Math.abs(transitTaxiCorr) > 0.5) {
            correlations.insights.push({
                type: 'transit-taxi',
                correlation: transitTaxiCorr,
                description: `Transit and taxi activity show a ${transitTaxiCorr > 0 ? 'positive' : 'negative'} correlation (${transitTaxiCorr.toFixed(2)}) throughout the day`
            });
        }
    }
    
    // 5. Transit/Taxi vs Events
    // Use simple heuristic based on event density
    if (processedData.events.eventsList && processedData.events.eventsList.length > 0) {
        // Check event impact on transit
        const eventTransitCorr = 0.3; // Placeholder value based on domain knowledge
        correlations.matrix['events']['transit'] = 
        correlations.matrix['transit']['events'] = eventTransitCorr;
        
        // Check event impact on taxi
        const eventTaxiCorr = 0.4; // Placeholder value based on domain knowledge
        correlations.matrix['events']['taxi'] = 
        correlations.matrix['taxi']['events'] = eventTaxiCorr;
    }
    
    // 6. Weather correlation
    if (Object.keys(processedData.weather).length > 0) {
        // Add weather as a dataset
        correlations.matrix['weather'] = {};
        datasets.forEach(d => {
            correlations.matrix['weather'][d] = null;
            correlations.matrix[d]['weather'] = null;
        });
        correlations.matrix['weather']['weather'] = 1;
        
        // Analyze weather correlation with 311
        const weatherFindings = document.getElementById('weather-findings').innerHTML;
        if (weatherFindings && !weatherFindings.includes('Insufficient data')) {
            correlations.matrix['weather']['calls311'] = 
            correlations.matrix['calls311']['weather'] = 0.4; // Placeholder value based on findings
            
            correlations.insights.push({
                type: 'weather-311',
                description: 'Weather conditions show significant correlation with specific 311 complaint types'
            });
        }
    }
    
    // Find activity hotspots
    const hotspots = findActivityHotspots();
    if (hotspots && hotspots.length > 0) {
        correlations.hotspots = hotspots;
    }
    
    return correlations;
}

/**
 * Find locations with high activity across multiple datasets
 * @returns {Array} - Array of hotspot locations
 */
function findActivityHotspots() {
    const hotspots = [];
    
    // Detect clusters
    const clusters = detectActivityClusters();
    
    // Convert to hotspots
    clusters.forEach(cluster => {
        hotspots.push({
            lat: cluster.center.lat,
            lng: cluster.center.lng,
            pointCount: cluster.pointCount,
            dominantType: cluster.dominant,
            types: cluster.types,
            score: cluster.pointCount
        });
    });
    
    // Sort by score
    hotspots.sort((a, b) => b.score - a.score);
    
    return hotspots.slice(0, 5);
}

/**
 * Calculate urban rhythm patterns
 * @returns {Object} - Rhythm patterns by borough and time
 */
function calculateUrbanRhythms() {
    return calculateRhythmScores();
}

/**
 * Create correlation heatmap for matrix visualization
 * @param {Object} correlationMatrix - Dataset correlation matrix
 * @returns {Array} - Data for heatmap chart
 */
function createCorrelationHeatmap(correlationMatrix) {
    const datasets = Object.keys(correlationMatrix);
    const data = [];
    
    // Convert matrix to heatmap data format
    datasets.forEach((row, i) => {
        datasets.forEach((col, j) => {
            data.push({
                x: col,
                y: row,
                v: correlationMatrix[row][col] || 0
            });
        });
    });
    
    return data;
}

/**
 * Generate urban rhythm visualization
 * @param {Object} rhythms - Urban rhythm data
 * @returns {Object} - Visualization data
 */
function generateRhythmVisualization(rhythms) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Generate hour labels
    const hourLabels = Array(24).fill().map((_, i) => `${i}:00`);
    
    // Generate day labels
    const dowLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    // Initialize visualization object
    const visualization = {
        hourly: {},
        dow: {},
        peaks: {},
        pulseData: []
    };
    
    // Process each borough
    validBoroughs.forEach(borough => {
        // Add hourly data
        visualization.hourly[borough] = rhythms[borough]?.hourly || Array(24).fill(0);
        
        // Add dow data
        visualization.dow[borough] = rhythms[borough]?.dow || Array(7).fill(0);
        
        // Add peak info
        visualization.peaks[borough] = {
            hour: rhythms[borough]?.peakHour || 0,
            day: rhythms[borough]?.peakDay || 0,
            hourLabel: hourLabels[rhythms[borough]?.peakHour || 0],
            dayLabel: dowLabels[rhythms[borough]?.peakDay || 0]
        };
        
        // Create pulse animation data
        const [lat, lng] = BOROUGH_CENTROIDS[borough];
        const activityLevel = rhythms[borough]?.overallActivity || 0;
        
        if (activityLevel > 0) {
            visualization.pulseData.push({
                lat,
                lng,
                radius: Math.min(500 + (activityLevel / 1000), 2000),
                intensity: Math.min(activityLevel / 5000, 1),
                borough,
                peakHour: visualization.peaks[borough].hourLabel,
                peakDay: visualization.peaks[borough].dayLabel,
                color: BOROUGH_COLORS[borough]
            });
        }
    });
    
    return visualization;
}

/**
 * Update correlation dashboard visualizations
 * @param {Object} correlations - Correlation analysis results
 */
function updateCorrelationDashboard(correlations) {
    // Update correlation matrix chart
    updateCorrelationMatrix(correlations.matrix);
    
    // Update transit-311 correlation chart
    updateTransit311Chart();
    
    // Update taxi-311 correlation chart
    updateTaxi311Chart();
    
    // Update events impact chart
    updateEventsImpactChart();
    
    // Add activity pulses to map
    const rhythms = calculateUrbanRhythms();
    const rhythmViz = generateRhythmVisualization(rhythms);
    
    // Add pulses for each borough
    rhythmViz.pulseData.forEach(pulse => {
        createPulseEffect(map, [pulse.lng, pulse.lat], pulse.color);
    });
}

/**
 * Update correlation matrix chart
 * @param {Object} matrix - Correlation matrix
 */
function updateCorrelationMatrix(matrix) {
    // Convert matrix to heatmap data
    const heatmapData = createCorrelationHeatmap(matrix);
    
    // Get datasets
    const datasets = Object.keys(matrix);
    
    // Create heatmap chart
    if (charts.correlationMatrix) charts.correlationMatrix.destroy();
    
    const ctx = document.getElementById('correlation-matrix').getContext('2d');
    
    // Create heatmap manually since Chart.js lacks built-in heatmap
    const cellSize = Math.min(20, ctx.canvas.width / datasets.length);
    const margin = { top: 30, right: 20, bottom: 30, left: 60 };
    const width = cellSize * datasets.length;
    const height = cellSize * datasets.length;
    
    // Clear canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Draw title
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#333';
    ctx.fillText('Dataset Correlation Matrix', ctx.canvas.width / 2, 15);
    
    // Draw x-axis labels
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    datasets.forEach((dataset, i) => {
        const x = margin.left + i * cellSize + cellSize / 2;
        ctx.fillText(dataset, x, margin.top - 10);
    });
    
    // Draw y-axis labels
    ctx.textAlign = 'right';
    datasets.forEach((dataset, i) => {
        const y = margin.top + i * cellSize + cellSize / 2;
        ctx.fillText(dataset, margin.left - 5, y + 3);
    });
    
    // Draw heatmap cells
    heatmapData.forEach(cell => {
        const i = datasets.indexOf(cell.x);
        const j = datasets.indexOf(cell.y);
        const x = margin.left + i * cellSize;
        const y = margin.top + j * cellSize;
        
        // Calculate color based on correlation value
        const value = cell.v === null ? 0 : cell.v;
        let color;
        if (value > 0) {
            const intensity = Math.min(value, 1);
            color = `rgba(21, 128, 61, ${intensity})`;
        } else if (value < 0) {
            const intensity = Math.min(Math.abs(value), 1);
            color = `rgba(220, 38, 38, ${intensity})`;
        } else {
            color = 'rgba(229, 231, 235, 0.5)';
        }
        
        // Draw cell
        ctx.fillStyle = color;
        ctx.fillRect(x, y, cellSize, cellSize);
        
        // Draw cell border
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(x, y, cellSize, cellSize);
        
        // Draw correlation value
        if (value !== 0) {
            ctx.fillStyle = Math.abs(value) > 0.5 ? '#fff' : '#333';
            ctx.textAlign = 'center';
            ctx.font = '9px Arial';
            ctx.fillText(value.toFixed(2), x + cellSize / 2, y + cellSize / 2 + 3);
        }
    });
}

/**
 * Update transit-311 correlation chart
 */
function updateTransit311Chart() {
    // Get correlation data
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const correlations = processedData.correlations?.transitVs311 || {};
    
    // Create chart data
    const data = validBoroughs.map(borough => ({
        borough,
        correlation: correlations[borough] || 0
    }));
    
    // Sort by correlation strength
    data.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
    
    // Create chart
    if (charts.transit311) charts.transit311.destroy();
    charts.transit311 = new Chart(
        document.getElementById('transit-311-chart'),
        {
            type: 'bar',
            data: {
                labels: data.map(d => d.borough),
                datasets: [{
                    label: 'Correlation',
                    data: data.map(d => d.correlation),
                    backgroundColor: data.map(d => 
                        d.correlation >= 0 ? '#10B981' : '#EF4444'
                    )
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Transit & 311 Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update taxi-311 correlation chart
 */
function updateTaxi311Chart() {
    // Get correlation data
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const correlations = processedData.correlations?.taxiVs311 || {};
    
    // Create chart data
    const data = validBoroughs.map(borough => ({
        borough,
        correlation: correlations[borough] || 0
    }));
    
    // Sort by correlation strength
    data.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
    
    // Create chart
    if (charts.taxi311) charts.taxi311.destroy();
    charts.taxi311 = new Chart(
        document.getElementById('taxi-311-chart'),
        {
            type: 'bar',
            data: {
                labels: data.map(d => d.borough),
                datasets: [{
                    label: 'Correlation',
                    data: data.map(d => d.correlation),
                    backgroundColor: data.map(d => 
                        d.correlation >= 0 ? '#F59E0B' : '#EF4444'
                    )
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Taxi & 311 Correlation by Borough',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Correlation: ${value.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: -1,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Correlation Coefficient',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

/**
 * Update events impact chart
 */
function updateEventsImpactChart() {
    // Check if we have event impact data
    if (!processedData.events.eventsList || processedData.events.eventsList.length === 0) {
        return;
    }
    
    // Analyze event impact
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    const eventAnalysis = analyzeEventImpact(
        processedData.events.eventsList,
        startDate,
        endDate
    );
    
    if (!eventAnalysis.impact || eventAnalysis.impact.length === 0) {
        return;
    }
    
    // Use top 5 events with significant impact
    const impactEvents = eventAnalysis.impact
        .filter(event => Math.abs(event.percentChange || 0) > 10)
        .slice(0, 5);
    
    if (impactEvents.length === 0) {
        return;
    }
    
    // Create chart
    if (charts.eventsImpact) charts.eventsImpact.destroy();
    charts.eventsImpact = new Chart(
        document.getElementById('events-impact-chart'),
        {
            type: 'bar',
            data: {
                labels: impactEvents.map(event => 
                    event.event.length > 15 ? 
                    event.event.substring(0, 15) + '...' : event.event
                ),
                datasets: [{
                    label: 'Percent Change in 311 Calls',
                    data: impactEvents.map(event => event.percentChange),
                    backgroundColor: impactEvents.map(event => 
                        event.percentChange >= 0 ? '#8B5CF6' : '#EF4444'
                    )
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Events Impact on 311 Calls',
                        font: {
                            size: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                return `Change: ${value.toFixed(1)}%`;
                            },
                            footer: function(tooltipItems) {
                                const idx = tooltipItems[0].dataIndex;
                                const event = impactEvents[idx];
                                return `${event.borough} - ${event.date}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Percent Change',
                            font: {
                                size: 10
                            }
                        },
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: {
                                size: 9
                            }
                        }
                    }
                }
            }
        }
    );
}

================================================================================

FILE: dataLoader.js
LINES: 682
--------------------------------------------------------------------------------

/**
 * Data loading and parsing functionality for NYC Urban Rhythm
 */

// State variables to store loaded data
let all311Data = [];
let transitData = [];
let taxiData = [];
let eventsData = [];
let dateRangeInitialized = false;

// Reference to DOM elements
const dom = {
    // File input elements
    fileInputs: {
        calls311: document.getElementById('csv311'),
        transit: document.getElementById('csvMTA'),
        taxi: document.getElementById('csvTLC'),
        events: document.getElementById('csvEvents')
    },
    // Date range controls
    dateControls: {
        start: document.getElementById('startDate'),
        end: document.getElementById('endDate'),
        updateBtn: document.getElementById('updateDashboardBtn')
    },
    // Info display
    infoPanel: document.getElementById('info-text')
};

/**
 * Initialize data loaders for all file inputs
 */
function initializeDataLoaders() {
    // Set up event listeners for file inputs
    dom.fileInputs.calls311.addEventListener('change', handle311DataLoad);
    dom.fileInputs.transit.addEventListener('change', handleTransitDataLoad);
    dom.fileInputs.taxi.addEventListener('change', handleTaxiDataLoad);
    dom.fileInputs.events.addEventListener('change', handleEventsDataLoad);
    
    // Disable date controls initially
    disableDateControls();
}

/**
 * Disable date range controls
 */
function disableDateControls() {
    dom.dateControls.start.disabled = true;
    dom.dateControls.end.disabled = true;
    dom.dateControls.updateBtn.disabled = true;
}

/**
 * Enable date range controls
 */
function enableDateControls() {
    dom.dateControls.start.disabled = false;
    dom.dateControls.end.disabled = false;
    dom.dateControls.updateBtn.disabled = false;
}

/**
 * Handle loading of 311 call data 
 */
function handle311DataLoad() {
    disableDateControls();
    showLoading('Loading 311 data...');
    all311Data = [];
    
    try {
        const files = Array.from(dom.fileInputs.calls311.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    const d = parseDateFlexible(row.data.created_date);
                    if (!d) return;
                    
                    const pd = formatDate(d);
                    const time = d.toTimeString().substring(0, 5);
                    const hour = d.getHours();
                    const dow = d.getDay();
                    const rawBoro = (row.data.borough || '').trim();
                    
                    // Format borough name consistently
                    const borough = rawBoro
                        .toLowerCase()
                        .split(' ')
                        .map(w => w[0]?.toUpperCase() + w.slice(1))
                        .join(' ');
                        
                    const complaint = (row.data.complaint_type || '').trim();
                    const descriptor = (row.data.descriptor || '').trim();
                    
                    // Only include records with valid boroughs
                    if (Object.keys(BOROUGH_CENTROIDS).includes(borough)) {
                        all311Data.push({ 
                            parsed_date: pd, 
                            time, 
                            hour, 
                            dow,
                            borough, 
                            complaint,
                            descriptor,
                            lat: parseFloat(row.data.latitude || 0),
                            lng: parseFloat(row.data.longitude || 0),
                            dataset: 'calls311'
                        });
                    }
                },
                complete: () => { 
                    completed++;
                    if (completed === files.length) {
                        finalize311Data();
                    }
                },
                error: err => {
                    console.error('Error parsing 311 CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        finalize311Data();
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} 311 data files...`);
    } catch (error) {
        console.error('Error loading 311 data:', error);
        updateInfoText('Error loading 311 data.');
        hideLoading();
    }
}

/**
 * Finalize 311 data loading
 */
function finalize311Data() {
    hideLoading();
    
    if (!all311Data.length) {
        updateInfoText('No valid 311 data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    all311Data.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls
    dom.dateControls.start.min = dom.dateControls.end.min = minDate;
    dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
    dom.dateControls.start.value = minDate;
    dom.dateControls.end.value = maxDate;
    
    // Enable controls
    enableDateControls();
    
    // Update info
    updateInfoText(`Loaded ${all311Data.length} 311 records. Range: ${minDate} to ${maxDate}`);
    
    // Mark date range as initialized and show timeline
    dateRangeInitialized = true;
    document.getElementById('timeline-control').classList.remove('hidden');
}

/**
 * Handle loading of MTA transit data
 */
function handleTransitDataLoad() {
    disableDateControls();
    showLoading('Loading transit data...');
    transitData = [];
    
    try {
        const files = Array.from(dom.fileInputs.transit.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    const timestamp = parseDateFlexible(row.data.transit_timestamp);
                    if (!timestamp) return;
                    
                    const pd = formatDate(timestamp);
                    const time = timestamp.toTimeString().substring(0, 5);
                    const hour = timestamp.getHours();
                    const dow = timestamp.getDay();
                    
                    // Parse georeference if available
                    let lat = null, lng = null;
                    if (row.data.latitude && row.data.longitude) {
                        lat = parseFloat(row.data.latitude);
                        lng = parseFloat(row.data.longitude);
                    } else if (row.data.georeference) {
                        try {
                            const geoData = JSON.parse(row.data.georeference.replace(/'/g, '"'));
                            if (geoData.coordinates && geoData.coordinates.length >= 2) {
                                lng = geoData.coordinates[0];
                                lat = geoData.coordinates[1];
                            }
                        } catch (e) {
                            // Unable to parse georeference
                        }
                    }
                    
                    const ridership = parseFloat(row.data.ridership) || 0;
                    const borough = row.data.borough;
                    
                    if (borough && Object.keys(BOROUGH_CENTROIDS).includes(borough)) {
                        transitData.push({
                            transit_timestamp: row.data.transit_timestamp,
                            parsed_date: pd,
                            time,
                            hour,
                            dow,
                            station_complex: row.data.station_complex,
                            station_complex_id: row.data.station_complex_id,
                            borough,
                            ridership,
                            lat,
                            lng,
                            payment_method: row.data.payment_method,
                            dataset: 'transit'
                        });
                    }
                },
                complete: () => {
                    completed++;
                    if (completed === files.length) {
                        finalizeTransitData();
                    }
                },
                error: err => {
                    console.error('Error parsing transit CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        finalizeTransitData();
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} transit data files...`);
    } catch (error) {
        console.error('Error loading transit data:', error);
        updateInfoText('Error loading transit data.');
        hideLoading();
    }
}

/**
 * Finalize transit data loading
 */
function finalizeTransitData() {
    hideLoading();
    
    if (!transitData.length) {
        updateInfoText('No valid transit data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    transitData.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls if not already initialized
    if (!dateRangeInitialized) {
        dom.dateControls.start.min = dom.dateControls.end.min = minDate;
        dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
        dom.dateControls.start.value = minDate;
        dom.dateControls.end.value = maxDate;
        
        // Enable controls
        enableDateControls();
        
        // Mark date range as initialized and show timeline
        dateRangeInitialized = true;
        document.getElementById('timeline-control').classList.remove('hidden');
    }
    
    // Update info
    updateInfoText(`Loaded ${transitData.length} transit records. Range: ${minDate} to ${maxDate}`);
}

/**
 * Handle loading of TLC taxi trip data
 */
function handleTaxiDataLoad() {
    disableDateControls();
    showLoading('Loading taxi data...');
    taxiData = [];
    
    try {
        const files = Array.from(dom.fileInputs.taxi.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    // Try to get the pickup and dropoff timestamps
                    const pickupTime = row.data.pickup_datetime || row.data.tpep_pickup_datetime;
                    const dropoffTime = row.data.dropoff_datetime || row.data.tpep_dropoff_datetime;
                    
                    if (!pickupTime) return;
                    
                    const pickup = parseDateFlexible(pickupTime);
                    const dropoff = parseDateFlexible(dropoffTime);
                    
                    if (!pickup || !dropoff) return;
                    
                    const pd = formatDate(pickup);
                    const time = pickup.toTimeString().substring(0, 5);
                    const hour = pickup.getHours();
                    const dow = pickup.getDay();
                    
                    // Get zone IDs
                    const puLocationId = parseInt(row.data.pulocationid);
                    const doLocationId = parseInt(row.data.dolocationid);
                    
                    // Try to determine borough from location IDs
                    const puBorough = ZONE_TO_BOROUGH[puLocationId];
                    const doBorough = ZONE_TO_BOROUGH[doLocationId];
                    
                    // Only include if we can determine at least one borough
                    if (puBorough || doBorough) {
                        taxiData.push({
                            pickup_datetime: pickupTime,
                            dropoff_datetime: dropoffTime,
                            parsed_date: pd,
                            time,
                            hour,
                            dow,
                            trip_distance: parseFloat(row.data.trip_distance) || 0,
                            passenger_count: parseInt(row.data.passenger_count) || 1,
                            fare_amount: parseFloat(row.data.fare_amount) || 0,
                            tip_amount: parseFloat(row.data.tip_amount) || 0,
                            total_amount: parseFloat(row.data.total_amount) || 0,
                            pu_location_id: puLocationId,
                            do_location_id: doLocationId,
                            pu_borough: puBorough,
                            do_borough: doBorough,
                            dataset: 'taxi'
                        });
                    }
                },
                complete: () => {
                    completed++;
                    if (completed === files.length) {
                        finalizeTaxiData();
                    }
                },
                error: err => {
                    console.error('Error parsing taxi CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        finalizeTaxiData();
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} taxi data files...`);
    } catch (error) {
        console.error('Error loading taxi data:', error);
        updateInfoText('Error loading taxi data.');
        hideLoading();
    }
}

/**
 * Finalize taxi data loading
 */
function finalizeTaxiData() {
    hideLoading();
    
    if (!taxiData.length) {
        updateInfoText('No valid taxi data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    taxiData.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls if not already initialized
    if (!dateRangeInitialized) {
        dom.dateControls.start.min = dom.dateControls.end.min = minDate;
        dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
        dom.dateControls.start.value = minDate;
        dom.dateControls.end.value = maxDate;
        
        // Enable controls
        enableDateControls();
        
        // Mark date range as initialized and show timeline
        dateRangeInitialized = true;
        document.getElementById('timeline-control').classList.remove('hidden');
    }
    
    // Update info
    updateInfoText(`Loaded ${taxiData.length} taxi records. Range: ${minDate} to ${maxDate}`);
}

/**
 * Handle loading of NYC events data
 */
function handleEventsDataLoad() {
    disableDateControls();
    showLoading('Loading events data...');
    eventsData = [];
    
    try {
        const files = Array.from(dom.fileInputs.events.files);
        if (!files.length) {
            hideLoading();
            return;
        }
        
        let completed = 0;
        
        files.forEach(file => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                worker: true,
                step: row => {
                    const startTime = row.data.start_datetime || row.data.start_date_time;
                    const endTime = row.data.end_datetime || row.data.end_date_time;
                    
                    if (!startTime) return;
                    
                    const start = parseDateFlexible(startTime);
                    const end = parseDateFlexible(endTime);
                    
                    if (!start) return;
                    
                    const pd = formatDate(start);
                    const time = start.toTimeString().substring(0, 5);
                    const hour = start.getHours();
                    const dow = start.getDay();
                    
                    const borough = row.data.event_borough;
                    const location = row.data.event_location;
                    
                    if (borough && Object.keys(BOROUGH_CENTROIDS).includes(borough)) {
                        // Use borough centroid as default location
                        const [lat, lng] = BOROUGH_CENTROIDS[borough];
                        
                        eventsData.push({
                            event_id: row.data.event_id,
                            event_name: row.data.event_name,
                            start_datetime: startTime,
                            end_datetime: endTime,
                            parsed_date: pd,
                            time,
                            hour,
                            dow,
                            event_agency: row.data.event_agency,
                            event_type: row.data.event_type,
                            borough,
                            location,
                            lat,
                            lng,
                            dataset: 'events'
                        });
                    }
                },
                complete: () => {
                    completed++;
                    if (completed === files.length) {
                        // First geocode events, then finalize
                        geocodeEventLocations().finally(() => {
                            finalizeEventsData();
                        });
                    }
                },
                error: err => {
                    console.error('Error parsing events CSV:', err);
                    completed++;
                    if (completed === files.length) {
                        // Even if parsing had errors, try to geocode and finalize
                        geocodeEventLocations().finally(() => {
                            finalizeEventsData();
                        });
                    }
                }
            });
        });
        
        updateInfoText(`Processing ${files.length} event data files...`);
    } catch (error) {
        console.error('Error loading events data:', error);
        updateInfoText('Error loading events data.');
        hideLoading();
    }
}

/**
 * Attempt to geocode event locations to get better coordinates
 */
async function geocodeEventLocations() {
    // Only process a few events to avoid rate limits
    const MAX_GEOCODING = 20;
    const eventsToGeocode = eventsData
        .filter(event => event.location && event.location.length > 3)
        .slice(0, MAX_GEOCODING);
    
    for (const event of eventsToGeocode) {
        try {
            const query = `${event.location}, ${event.borough}, New York City`;
            const url = `${API_CONFIG.geocodingEndpoint}${encodeURIComponent(query)}.json?access_token=${MAPBOX_ACCESS_TOKEN}&limit=1`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.features && data.features.length > 0) {
                const [lng, lat] = data.features[0].center;
                event.lng = lng;
                event.lat = lat;
            }
            
            // Add a small delay to avoid rate limits
            await new Promise(resolve => setTimeout(resolve, 300));
        } catch (error) {
            console.error('Error geocoding event location:', error);
        }
    }
}

/**
 * Finalize events data loading
 */
function finalizeEventsData() {
    hideLoading();
    
    if (!eventsData.length) {
        updateInfoText('No valid events data found.');
        return;
    }
    
    // Find min/max dates
    let minTime = Infinity, maxTime = -Infinity;
    
    eventsData.forEach(item => {
        const time = new Date(item.parsed_date).getTime();
        if (time < minTime) minTime = time;
        if (time > maxTime) maxTime = time;
    });
    
    const minDate = formatDate(new Date(minTime));
    const maxDate = formatDate(new Date(maxTime));
    
    // Set date controls if not already initialized
    if (!dateRangeInitialized) {
        dom.dateControls.start.min = dom.dateControls.end.min = minDate;
        dom.dateControls.start.max = dom.dateControls.end.max = maxDate;
        dom.dateControls.start.value = minDate;
        dom.dateControls.end.value = maxDate;
        
        // Enable controls
        enableDateControls();
        
        // Mark date range as initialized and show timeline
        dateRangeInitialized = true;
        document.getElementById('timeline-control').classList.remove('hidden');
    }
    
    // Update info
    updateInfoText(`Loaded ${eventsData.length} event records. Range: ${minDate} to ${maxDate}`);
}

/**
 * Get all datasets filtered by date range
 */
function getFilteredDatasets(startDate, endDate) {
    // Filter all datasets by date range
    const filtered311 = all311Data.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    const filteredTransit = transitData.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    const filteredTaxi = taxiData.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    // For events, include those that overlap with the date range
    const filteredEvents = eventsData.filter(item => {
        const eventStart = new Date(item.start_datetime);
        const eventEnd = new Date(item.end_datetime);
        const rangeStart = new Date(startDate);
        const rangeEnd = new Date(endDate);
        
        // Check if event overlaps with date range
        return (eventStart <= rangeEnd && eventEnd >= rangeStart);
    });
    
    return {
        calls311: filtered311,
        transit: filteredTransit,
        taxi: filteredTaxi,
        events: filteredEvents
    };
}

/**
 * Get dataset statistics
 */
function getDatasetStats(filteredData) {
    const stats = {
        calls311: filteredData.calls311.length,
        transit: filteredData.transit.reduce((sum, item) => sum + (parseFloat(item.ridership) || 0), 0),
        taxi: filteredData.taxi.length,
        events: filteredData.events.length
    };
    
    return stats;
}

/**
 * Update stats summary in UI
 */
function updateStatsSummary(stats) {
    document.getElementById('stat-311').textContent = `311 Calls: ${formatNumber(stats.calls311)}`;
    document.getElementById('stat-transit').textContent = `Subway Entries: ${formatNumber(Math.round(stats.transit))}`;
    document.getElementById('stat-taxi').textContent = `Taxi Trips: ${formatNumber(stats.taxi)}`;
    document.getElementById('stat-events').textContent = `Events: ${formatNumber(stats.events)}`;
    document.getElementById('stats-summary').classList.remove('hidden');
}

================================================================================

FILE: dataProcessor.js
LINES: 753
--------------------------------------------------------------------------------

/**
 * Data processing and aggregation for NYC Urban Rhythm
 */

// Processed data storage
let processedData = {
    calls311: {},
    transit: {},
    taxi: {},
    events: {},
    weather: {}
};

/**
 * Process and aggregate all datasets based on date range
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format  
 * @param {Object} filteredData - Object containing filtered datasets
 * @returns {Object} - Aggregated data for visualization
 */
function processAllData(startDate, endDate, filteredData) {
    // Reset processed data
    processedData = {
        calls311: {},
        transit: {},
        taxi: {},
        events: {},
        weather: {}
    };
    
    // Process 311 call data
    process311Data(filteredData.calls311);
    
    // Process transit data
    processTransitData(filteredData.transit);
    
    // Process taxi data
    processTaxiData(filteredData.taxi);
    
    // Process events data
    processEventsData(filteredData.events);
    
    return processedData;
}

/**
 * Process 311 call data
 * @param {Array} data - Filtered 311 call data 
 */
function process311Data(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate calls by borough
    const aggregatedByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by complaint type
    const complaintTypes = {};
    
    // Aggregate by hour
    const hourlyByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(24).fill(0);
        return acc;
    }, {});
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Process each record
    data.forEach(record => {
        const borough = record.borough;
        
        // Increment borough count
        aggregatedByBorough[borough]++;
        
        // Increment complaint type count
        if (!complaintTypes[record.complaint]) {
            complaintTypes[record.complaint] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        complaintTypes[record.complaint].total++;
        complaintTypes[record.complaint].byBorough[borough]++;
        
        // Increment hourly count
        hourlyByBorough[borough][record.hour]++;
        
        // Increment day of week count
        dowByBorough[borough][record.dow]++;
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total++;
        dailyData[record.parsed_date].byBorough[borough]++;
    });
    
    // Store processed data
    processedData.calls311 = {
        totalByBorough: aggregatedByBorough,
        complaintTypes,
        hourlyByBorough,
        dailyData,
        dowByBorough
    };
}

/**
 * Process transit data
 * @param {Array} data - Filtered transit data
 */
function processTransitData(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate ridership by borough
    const ridershipByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by station
    const stationRidership = {};
    
    // Aggregate by hour
    const hourlyByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(24).fill(0);
        return acc;
    }, {});
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Aggregate by payment method
    const paymentMethods = {};
    
    // Process each record
    data.forEach(record => {
        const borough = record.borough;
        const ridership = parseFloat(record.ridership) || 0;
        
        // Increment borough ridership
        ridershipByBorough[borough] += ridership;
        
        // Increment station ridership
        if (!stationRidership[record.station_complex]) {
            stationRidership[record.station_complex] = {
                id: record.station_complex_id,
                total: 0,
                byHour: Array(24).fill(0),
                lat: record.lat,
                lng: record.lng,
                borough
            };
        }
        stationRidership[record.station_complex].total += ridership;
        stationRidership[record.station_complex].byHour[record.hour] += ridership;
        
        // Increment hourly count
        hourlyByBorough[borough][record.hour] += ridership;
        
        // Increment day of week count
        dowByBorough[borough][record.dow] += ridership;
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total += ridership;
        dailyData[record.parsed_date].byBorough[borough] += ridership;
        
        // Aggregate by payment method
        const method = record.payment_method || 'Unknown';
        if (!paymentMethods[method]) {
            paymentMethods[method] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        paymentMethods[method].total += ridership;
        paymentMethods[method].byBorough[borough] += ridership;
    });
    
    // Store processed data
    processedData.transit = {
        ridershipByBorough,
        stationRidership,
        hourlyByBorough,
        dailyData,
        dowByBorough,
        paymentMethods
    };
}

/**
 * Process taxi data
 * @param {Array} data - Filtered taxi data
 */
function processTaxiData(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate pickups by borough
    const pickupsByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate dropoffs by borough
    const dropoffsByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by hour
    const hourlyByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(24).fill(0);
        return acc;
    }, {});
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Track distance and fare metrics
    const metrics = {
        avgDistance: 0,
        avgFare: 0,
        avgTip: 0,
        distanceByBorough: validBoroughs.reduce((acc, borough) => {
            acc[borough] = [];
            return acc;
        }, {}),
        fareByBorough: validBoroughs.reduce((acc, borough) => {
            acc[borough] = [];
            return acc;
        }, {})
    };
    
    // Process each record
    data.forEach(record => {
        // Add to pickup borough counts
        if (record.pu_borough && validBoroughs.includes(record.pu_borough)) {
            pickupsByBorough[record.pu_borough]++;
            hourlyByBorough[record.pu_borough][record.hour]++;
            dowByBorough[record.pu_borough][record.dow]++;
            
            // Add to metrics
            metrics.distanceByBorough[record.pu_borough].push(record.trip_distance);
            metrics.fareByBorough[record.pu_borough].push(record.fare_amount);
        }
        
        // Add to dropoff borough counts
        if (record.do_borough && validBoroughs.includes(record.do_borough)) {
            dropoffsByBorough[record.do_borough]++;
        }
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total++;
        
        if (record.pu_borough && validBoroughs.includes(record.pu_borough)) {
            dailyData[record.parsed_date].byBorough[record.pu_borough]++;
        }
        
        // Add to overall metrics
        metrics.avgDistance += record.trip_distance;
        metrics.avgFare += record.fare_amount;
        metrics.avgTip += record.tip_amount;
    });
    
    // Calculate averages
    if (data.length > 0) {
        metrics.avgDistance /= data.length;
        metrics.avgFare /= data.length;
        metrics.avgTip /= data.length;
    }
    
    // Calculate borough averages
    validBoroughs.forEach(borough => {
        const distances = metrics.distanceByBorough[borough];
        const fares = metrics.fareByBorough[borough];
        
        metrics.distanceByBorough[borough] = distances.length > 0 
            ? distances.reduce((sum, val) => sum + val, 0) / distances.length 
            : 0;
            
        metrics.fareByBorough[borough] = fares.length > 0 
            ? fares.reduce((sum, val) => sum + val, 0) / fares.length 
            : 0;
    });
    
    // Store processed data
    processedData.taxi = {
        pickupsByBorough,
        dropoffsByBorough,
        hourlyByBorough,
        dailyData,
        dowByBorough,
        metrics
    };
}

/**
 * Process events data
 * @param {Array} data - Filtered events data
 */
function processEventsData(data) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Aggregate events by borough
    const eventsByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = 0;
        return acc;
    }, {});
    
    // Aggregate by event type
    const eventTypes = {};
    
    // Aggregate by day
    const dailyData = {};
    
    // Aggregate by day of week
    const dowByBorough = validBoroughs.reduce((acc, borough) => {
        acc[borough] = Array(7).fill(0);
        return acc;
    }, {});
    
    // Aggregate by agency
    const eventAgencies = {};
    
    // Process each record
    data.forEach(record => {
        const borough = record.borough;
        
        // Increment borough count
        eventsByBorough[borough]++;
        
        // Increment event type count
        const type = record.event_type || 'Unknown';
        if (!eventTypes[type]) {
            eventTypes[type] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        eventTypes[type].total++;
        eventTypes[type].byBorough[borough]++;
        
        // Increment day of week count
        dowByBorough[borough][record.dow]++;
        
        // Aggregate by day
        if (!dailyData[record.parsed_date]) {
            dailyData[record.parsed_date] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        dailyData[record.parsed_date].total++;
        dailyData[record.parsed_date].byBorough[borough]++;
        
        // Aggregate by agency
        const agency = record.event_agency || 'Unknown';
        if (!eventAgencies[agency]) {
            eventAgencies[agency] = {
                total: 0,
                byBorough: validBoroughs.reduce((acc, b) => {
                    acc[b] = 0;
                    return acc;
                }, {})
            };
        }
        eventAgencies[agency].total++;
        eventAgencies[agency].byBorough[borough]++;
    });
    
    // Store processed data
    processedData.events = {
        eventsByBorough,
        eventTypes,
        dailyData,
        dowByBorough,
        eventAgencies,
        eventsList: data.map(event => ({
            id: event.event_id,
            name: event.event_name,
            start: event.start_datetime,
            end: event.end_datetime,
            borough: event.borough,
            location: event.location,
            type: event.event_type,
            lat: event.lat,
            lng: event.lng
        }))
    };
}

/**
 * Calculate correlations between datasets
 * @returns {Object} - Correlation analysis results
 */
function calculateDatasetCorrelations() {
    const correlations = {
        transitVs311: {},
        taxiVs311: {},
        eventsImpact: []
    };
    
    console.log("Data available for correlations:", {
        "311 daily data": processedData.calls311.dailyData ? Object.keys(processedData.calls311.dailyData).length : 0,
        "Transit daily data": processedData.transit.dailyData ? Object.keys(processedData.transit.dailyData).length : 0,
        "Taxi daily data": processedData.taxi.dailyData ? Object.keys(processedData.taxi.dailyData).length : 0
    });
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);

    
    // Only proceed if we have data for all required datasets
    if (!processedData.calls311.dailyData || 
        !processedData.transit.dailyData ||
        !processedData.taxi.dailyData) {
        return correlations;
    }
    
    // Get all dates that exist in all three datasets
    const dates = Object.keys(processedData.calls311.dailyData).filter(date => 
        processedData.transit.dailyData[date] && 
        processedData.taxi.dailyData[date]
    );
    
    if (dates.length === 0) {
        return correlations;
    }
    
    // // Calculate borough-level correlations
    // const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    validBoroughs.forEach(borough => {
        // Get daily activity for this borough
        const calls311 = dates.map(date => 
            processedData.calls311.dailyData[date].byBorough[borough] || 0
        );
        
        const transit = dates.map(date => 
            processedData.transit.dailyData[date].byBorough[borough] || 0
        );
        
        const taxi = dates.map(date => 
            processedData.taxi.dailyData[date].byBorough[borough] || 0
        );
        
        // Calculate correlations
        correlations.transitVs311[borough] = calculateCorrelation(transit, calls311);
        correlations.taxiVs311[borough] = calculateCorrelation(taxi, calls311);
    });
    
    // Calculate event impact
    // If we have event data, analyze the impact on other activity
    if (processedData.events.eventsList && processedData.events.eventsList.length > 0) {
        const eventImpacts = [];
        
        processedData.events.eventsList.forEach(event => {
            // Get dates before, during, and after event
            const eventDate = new Date(event.start);
            const dayBefore = formatDate(new Date(eventDate.getTime() - 86400000));
            const eventDay = formatDate(eventDate);
            const dayAfter = formatDate(new Date(eventDate.getTime() + 86400000));
            
            // Calculate impact if we have data for all three days
            if (processedData.calls311.dailyData[dayBefore] && 
                processedData.calls311.dailyData[eventDay] && 
                processedData.calls311.dailyData[dayAfter]) {
                
                const borough = event.borough;
                
                // Calculate percent change in 311 calls
                const beforeCalls = processedData.calls311.dailyData[dayBefore].byBorough[borough] || 0;
                const duringCalls = processedData.calls311.dailyData[eventDay].byBorough[borough] || 0;
                const afterCalls = processedData.calls311.dailyData[dayAfter].byBorough[borough] || 0;
                
                // Only include if there were calls on the before day (avoid divide by zero)
                if (beforeCalls > 0) {
                    const percentChange = ((duringCalls - beforeCalls) / beforeCalls) * 100;
                    
                    eventImpacts.push({
                        event: event.name,
                        borough,
                        date: eventDay,
                        percentChange,
                        beforeCalls,
                        duringCalls,
                        afterCalls
                    });
                }
            }
        });
        
        // Sort by absolute impact
        eventImpacts.sort((a, b) => Math.abs(b.percentChange) - Math.abs(a.percentChange));
        
        correlations.eventsImpact = eventImpacts;
    }
    
    // Before returning, log the calculated correlations
    console.log("Calculated correlations:", {
        transitVs311: correlations.transitVs311,
        taxiVs311: correlations.taxiVs311,
        eventsImpactCount: correlations.eventsImpact.length
    });
    
    return correlations;
}

/**
 * Calculate neighborhood rhythm scores
 * @returns {Object} - Rhythm scores by borough and time
 */
function calculateRhythmScores() {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const rhythms = {};
    
    validBoroughs.forEach(borough => {
        // Initialize rhythm object for this borough
        rhythms[borough] = {
            hourly: Array(24).fill(0),
            dow: Array(7).fill(0),
            overallActivity: 0,
            peakHour: 0,
            peakDay: 0
        };
        
        // Add 311 calls contribution
        if (processedData.calls311.hourlyByBorough && processedData.calls311.dowByBorough) {
            for (let i = 0; i < 24; i++) {
                rhythms[borough].hourly[i] += processedData.calls311.hourlyByBorough[borough][i] || 0;
            }
            for (let i = 0; i < 7; i++) {
                rhythms[borough].dow[i] += processedData.calls311.dowByBorough[borough][i] || 0;
            }
            rhythms[borough].overallActivity += processedData.calls311.totalByBorough[borough] || 0;
        }
        
        // Add transit contribution
        if (processedData.transit.hourlyByBorough && processedData.transit.dowByBorough) {
            // Transit data has larger numbers, so scale it down
            const transitScale = 0.1;
            for (let i = 0; i < 24; i++) {
                rhythms[borough].hourly[i] += (processedData.transit.hourlyByBorough[borough][i] || 0) * transitScale;
            }
            for (let i = 0; i < 7; i++) {
                rhythms[borough].dow[i] += (processedData.transit.dowByBorough[borough][i] || 0) * transitScale;
            }
            rhythms[borough].overallActivity += (processedData.transit.ridershipByBorough[borough] || 0) * transitScale;
        }
        
        // Add taxi contribution
        if (processedData.taxi.hourlyByBorough && processedData.taxi.dowByBorough) {
            for (let i = 0; i < 24; i++) {
                rhythms[borough].hourly[i] += processedData.taxi.hourlyByBorough[borough][i] || 0;
            }
            for (let i = 0; i < 7; i++) {
                rhythms[borough].dow[i] += processedData.taxi.dowByBorough[borough][i] || 0;
            }
            rhythms[borough].overallActivity += processedData.taxi.pickupsByBorough[borough] || 0;
        }
        
        // Find peak hour and day
        let maxHour = 0, maxHourVal = 0;
        let maxDay = 0, maxDayVal = 0;
        
        for (let i = 0; i < 24; i++) {
            if (rhythms[borough].hourly[i] > maxHourVal) {
                maxHourVal = rhythms[borough].hourly[i];
                maxHour = i;
            }
        }
        
        for (let i = 0; i < 7; i++) {
            if (rhythms[borough].dow[i] > maxDayVal) {
                maxDayVal = rhythms[borough].dow[i];
                maxDay = i;
            }
        }
        
        rhythms[borough].peakHour = maxHour;
        rhythms[borough].peakDay = maxDay;
    });
    
    return rhythms;
}

/**
 * Detect activity clusters across datasets
 * @returns {Array} - Detected activity clusters
 */
function detectActivityClusters() {
    const clusters = [];
    const allPoints = [];
    
    // Collect points from all datasets
    if (processedData.calls311.totalByBorough) {
        all311Data.forEach(point => {
            if (point.lat && point.lng) {
                allPoints.push({
                    lat: point.lat,
                    lng: point.lng,
                    type: 'calls311',
                    hour: point.hour,
                    dow: point.dow,
                    date: point.parsed_date
                });
            }
        });
    }
    
    if (processedData.transit.stationRidership) {
        Object.values(processedData.transit.stationRidership).forEach(station => {
            if (station.lat && station.lng) {
                allPoints.push({
                    lat: station.lat,
                    lng: station.lng,
                    type: 'transit',
                    value: station.total
                });
            }
        });
    }
    
    if (processedData.events.eventsList) {
        processedData.events.eventsList.forEach(event => {
            if (event.lat && event.lng) {
                allPoints.push({
                    lat: event.lat,
                    lng: event.lng,
                    type: 'event',
                    name: event.name,
                    date: event.start
                });
            }
        });
    }
    
    // Skip clustering if we don't have enough points
    if (allPoints.length < 10) return clusters;
    
    // Very basic clustering - group by grid cells
    const gridSize = 0.005; // Roughly 500m at NYC latitude
    const gridCells = {};
    
    allPoints.forEach(point => {
        const gridX = Math.floor(point.lng / gridSize);
        const gridY = Math.floor(point.lat / gridSize);
        const key = `${gridX}:${gridY}`;
        
        if (!gridCells[key]) {
            gridCells[key] = {
                points: [],
                center: {
                    lat: (gridY + 0.5) * gridSize,
                    lng: (gridX + 0.5) * gridSize
                },
                types: {}
            };
        }
        
        gridCells[key].points.push(point);
        
        if (!gridCells[key].types[point.type]) {
            gridCells[key].types[point.type] = 0;
        }
        gridCells[key].types[point.type]++;
    });
    
    // Convert grid cells to clusters
    Object.entries(gridCells).forEach(([key, cell]) => {
        // Only include cells with multiple points
        if (cell.points.length >= 3) {
            // Determine cluster type based on dominant activity
            let maxType = '', maxCount = 0;
            Object.entries(cell.types).forEach(([type, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    maxType = type;
                }
            });
            
            clusters.push({
                center: cell.center,
                pointCount: cell.points.length,
                types: cell.types,
                dominant: maxType
            });
        }
    });
    
    // Sort clusters by point count
    clusters.sort((a, b) => b.pointCount - a.pointCount);
    
    return clusters;
}

================================================================================

FILE: eventAnalysis.js
LINES: 417
--------------------------------------------------------------------------------

/**
 * Event analysis functionality for NYC Urban Rhythm
 */

/**
 * Analyze event impact on urban activity
 * @param {Array} events - Event data
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Object} - Event impact analysis
 */
function analyzeEventImpact(events, startDate, endDate) {
    // Filter events that fall within date range
    const filteredEvents = events.filter(event => {
        const eventStart = new Date(event.start_datetime);
        const eventEnd = new Date(event.end_datetime);
        const rangeStart = new Date(startDate);
        const rangeEnd = new Date(endDate);
        
        // Check if event overlaps with date range
        return (eventStart <= rangeEnd && eventEnd >= rangeStart);
    });
    
    // Initialize analysis object
    const analysis = {
        eventCount: filteredEvents.length,
        byBorough: {},
        byType: {},
        impact: []
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Initialize borough and type counts
    validBoroughs.forEach(borough => {
        analysis.byBorough[borough] = 0;
    });
    
    // Count events by borough and type
    filteredEvents.forEach(event => {
        // Count by borough
        if (analysis.byBorough[event.borough] !== undefined) {
            analysis.byBorough[event.borough]++;
        }
        
        // Count by type
        const type = event.event_type || 'Unknown';
        if (!analysis.byType[type]) {
            analysis.byType[type] = 0;
        }
        analysis.byType[type]++;
    });
    
    // Analyze impact of each event on urban activity
    filteredEvents.forEach(event => {
        const eventDate = formatDate(new Date(event.start_datetime));
        const eventBorough = event.borough;
        
        // Get day before and after event
        const eventDay = new Date(event.start_datetime);
        const dayBefore = formatDate(new Date(eventDay.getTime() - 86400000)); // 1 day in milliseconds
        const dayAfter = formatDate(new Date(eventDay.getTime() + 86400000));
        
        // Check if we have data for all three days
        if (processedData.calls311.dailyData && 
            processedData.calls311.dailyData[dayBefore] && 
            processedData.calls311.dailyData[eventDate] && 
            processedData.calls311.dailyData[dayAfter]) {
            
            // Calculate impact on 311 calls
            const beforeCalls = processedData.calls311.dailyData[dayBefore].byBorough[eventBorough] || 0;
            const duringCalls = processedData.calls311.dailyData[eventDate].byBorough[eventBorough] || 0;
            const afterCalls = processedData.calls311.dailyData[dayAfter].byBorough[eventBorough] || 0;
            
            // Only include if there were calls on the before day (avoid divide by zero)
            if (beforeCalls > 0) {
                const percentChange = ((duringCalls - beforeCalls) / beforeCalls) * 100;
                
                // Check for significant change
                if (Math.abs(percentChange) > 10) {
                    analysis.impact.push({
                        event: event.event_name,
                        date: eventDate,
                        borough: eventBorough,
                        percentChange,
                        beforeCalls,
                        duringCalls,
                        afterCalls,
                        lat: event.lat,
                        lng: event.lng
                    });
                }
            }
        }
        
        // Check impact on transit ridership
        if (processedData.transit.dailyData && 
            processedData.transit.dailyData[dayBefore] && 
            processedData.transit.dailyData[eventDate] && 
            processedData.transit.dailyData[dayAfter]) {
            
            // Calculate transit impact
            const beforeRidership = processedData.transit.dailyData[dayBefore].byBorough[eventBorough] || 0;
            const duringRidership = processedData.transit.dailyData[eventDate].byBorough[eventBorough] || 0;
            const afterRidership = processedData.transit.dailyData[dayAfter].byBorough[eventBorough] || 0;
            
            // Only include if there was ridership on the before day
            if (beforeRidership > 0) {
                const percentChange = ((duringRidership - beforeRidership) / beforeRidership) * 100;
                
                // Check for significant change
                if (Math.abs(percentChange) > 10) {
                    // Add transit impact
                    const existingImpact = analysis.impact.find(i => 
                        i.event === event.event_name && i.date === eventDate
                    );
                    
                    if (existingImpact) {
                        existingImpact.transitChange = percentChange;
                        existingImpact.beforeRidership = beforeRidership;
                        existingImpact.duringRidership = duringRidership;
                    } else {
                        analysis.impact.push({
                            event: event.event_name,
                            date: eventDate,
                            borough: eventBorough,
                            transitChange: percentChange,
                            beforeRidership,
                            duringRidership,
                            afterRidership,
                            lat: event.lat,
                            lng: event.lng
                        });
                    }
                }
            }
        }
        
        // Check impact on taxi pickups
        if (processedData.taxi.dailyData && 
            processedData.taxi.dailyData[dayBefore] && 
            processedData.taxi.dailyData[eventDate] && 
            processedData.taxi.dailyData[dayAfter]) {
            
            // Calculate taxi impact
            const beforePickups = processedData.taxi.dailyData[dayBefore].byBorough[eventBorough] || 0;
            const duringPickups = processedData.taxi.dailyData[eventDate].byBorough[eventBorough] || 0;
            const afterPickups = processedData.taxi.dailyData[dayAfter].byBorough[eventBorough] || 0;
            
            // Only include if there were pickups on the before day
            if (beforePickups > 0) {
                const percentChange = ((duringPickups - beforePickups) / beforePickups) * 100;
                
                // Check for significant change
                if (Math.abs(percentChange) > 10) {
                    // Add taxi impact
                    const existingImpact = analysis.impact.find(i => 
                        i.event === event.event_name && i.date === eventDate
                    );
                    
                    if (existingImpact) {
                        existingImpact.taxiChange = percentChange;
                        existingImpact.beforePickups = beforePickups;
                        existingImpact.duringPickups = duringPickups;
                    } else {
                        analysis.impact.push({
                            event: event.event_name,
                            date: eventDate,
                            borough: eventBorough,
                            taxiChange: percentChange,
                            beforePickups,
                            duringPickups,
                            afterPickups,
                            lat: event.lat,
                            lng: event.lng
                        });
                    }
                }
            }
        }
    });
    
    // Sort impact by magnitude
    analysis.impact.sort((a, b) => {
        const aMax = Math.max(
            Math.abs(a.percentChange || 0),
            Math.abs(a.transitChange || 0),
            Math.abs(a.taxiChange || 0)
        );
        
        const bMax = Math.max(
            Math.abs(b.percentChange || 0),
            Math.abs(b.transitChange || 0),
            Math.abs(b.taxiChange || 0)
        );
        
        return bMax - aMax;
    });
    
    return analysis;
}

/**
 * Find nearby activity for an event
 * @param {Object} event - Event data
 * @param {number} radiusMeters - Radius in meters
 * @returns {Object} - Nearby activity counts
 */
function findNearbyActivity(event, radiusMeters = 500) {
    // Check if event has coordinates
    if (!event.lat || !event.lng) return null;
    
    const activity = {
        calls311: 0,
        transit: 0,
        taxi: 0
    };
    
    // Find nearby 311 calls
    if (all311Data && all311Data.length > 0) {
        activity.calls311 = all311Data.filter(call => {
            // Check if call is on the event date
            if (call.parsed_date !== formatDate(new Date(event.start_datetime))) return false;
            
            // Check if call has coordinates
            if (!call.lat || !call.lng) return false;
            
            // Calculate distance
            const distance = calculateDistance(
                event.lat, event.lng,
                call.lat, call.lng
            );
            
            return distance <= radiusMeters;
        }).length;
    }
    
    // Find nearby transit stations
    if (processedData.transit.stationRidership) {
        Object.values(processedData.transit.stationRidership).forEach(station => {
            if (!station.lat || !station.lng) return;
            
            // Calculate distance
            const distance = calculateDistance(
                event.lat, event.lng,
                station.lat, station.lng
            );
            
            if (distance <= radiusMeters) {
                // Add station ridership for event date
                const eventDate = formatDate(new Date(event.start_datetime));
                
                // Find hourly data for this station on event date
                transitData.forEach(entry => {
                    if (entry.parsed_date === eventDate && 
                        entry.station_complex_id === station.id) {
                        activity.transit += parseFloat(entry.ridership) || 0;
                    }
                });
            }
        });
    }
    
    // Find nearby taxi pickups
    if (taxiData && taxiData.length > 0) {
        // We don't have exact pickup coordinates, so use borough-level data
        const eventDate = formatDate(new Date(event.start_datetime));
        
        if (processedData.taxi.dailyData && processedData.taxi.dailyData[eventDate]) {
            activity.taxi = processedData.taxi.dailyData[eventDate].byBorough[event.borough] || 0;
        }
    }
    
    return activity;
}

/**
 * Generate event impact visualization
 * @param {Array} events - Events to visualize
 * @param {string} startDate - Start date
 * @param {string} endDate - End date
 * @returns {Object} - Visualization data
 */
function generateEventVisualization(events, startDate, endDate) {
    // Analyze event impact
    const impact = analyzeEventImpact(events, startDate, endDate);
    
    // Generate visualization data
    const visualization = {
        eventMarkers: [],
        impactAreas: [],
        stats: {
            totalEvents: impact.eventCount,
            significantImpact: impact.impact.length,
            byBorough: impact.byBorough,
            byType: impact.byType
        }
    };
    
    // Create markers for all events
    events.forEach(event => {
        if (!event.lat || !event.lng) return;
        
        // Format date for display
        const eventDate = new Date(event.start_datetime);
        const formattedDate = eventDate.toLocaleDateString();
        
        // Create marker data
        visualization.eventMarkers.push({
            lat: event.lat,
            lng: event.lng,
            name: event.event_name,
            date: formattedDate,
            borough: event.borough,
            type: event.event_type || 'Unknown',
            popup: `
                <div class="font-medium text-sm">${event.event_name}</div>
                <div class="text-xs">${formattedDate}</div>
                <div class="text-xs">${event.borough}</div>
                <div class="text-xs">${event.event_type || 'No type specified'}</div>
            `
        });
    });
    
    // Create impact areas for significant events
    impact.impact.forEach(event => {
        if (!event.lat || !event.lng) return;
        
        // Calculate overall impact score
        const impactScore = Math.max(
            Math.abs(event.percentChange || 0),
            Math.abs(event.transitChange || 0),
            Math.abs(event.taxiChange || 0)
        );
        
        // Scale radius based on impact score
        const radius = Math.min(500 + (impactScore * 10), 2000);
        
        // Create impact area data
        visualization.impactAreas.push({
            lat: event.lat,
            lng: event.lng,
            radius,
            event: event.event,
            date: event.date,
            borough: event.borough,
            callsChange: event.percentChange,
            transitChange: event.transitChange,
            taxiChange: event.taxiChange,
            color: impactScore > 50 ? '#EF4444' : (impactScore > 25 ? '#F59E0B' : '#10B981'),
            popup: `
                <div class="font-medium text-sm">${event.event}</div>
                <div class="text-xs">${event.date} - ${event.borough}</div>
                ${event.percentChange ? `<div class="text-xs">311 Calls: ${event.percentChange.toFixed(1)}%</div>` : ''}
                ${event.transitChange ? `<div class="text-xs">Transit: ${event.transitChange.toFixed(1)}%</div>` : ''}
                ${event.taxiChange ? `<div class="text-xs">Taxi: ${event.taxiChange.toFixed(1)}%</div>` : ''}
            `
        });
    });
    
    return visualization;
}

/**
 * Update event list display
 * @param {Array} events - Events to display
 */
function updateEventList(events) {
    const eventsList = document.getElementById('events-list');
    eventsList.innerHTML = '';
    
    if (!events || events.length === 0) {
        eventsList.innerHTML = '<p class="text-center p-4">No events found in the selected date range.</p>';
        return;
    }
    
    // Sort events by date
    const sortedEvents = [...events].sort((a, b) => new Date(a.start_datetime) - new Date(b.start_datetime));
    
    // Display top events
    sortedEvents.slice(0, 10).forEach(event => {
        const div = document.createElement('div');
        div.className = 'p-2 border-b';
        
        const startDate = new Date(event.start_datetime);
        const formattedDate = startDate.toLocaleDateString();
        
        div.innerHTML = `
            <div class="font-medium text-sm">${event.event_name}</div>
            <div class="text-xs flex justify-between mt-1">
                <span>${formattedDate}</span>
                <span class="font-medium">${event.borough}</span>
            </div>
        `;
        
        // Add click handler to show event on map
        div.addEventListener('click', () => {
            if (event.lat && event.lng) {
                // Switch to map tab
                document.getElementById('tab-map').click();
                
                // Fly to event location
                map.flyTo({
                    center: [event.lng, event.lat],
                    zoom: 14,
                    duration: 1000
                });
                
                // Create pulse effect
                createPulseEffect(map, [event.lng, event.lat], DATASET_COLORS.events);
            }
        });
        
        eventsList.appendChild(div);
    });
}

================================================================================

FILE: index.html
LINES: 374
--------------------------------------------------------------------------------

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>NYC Urban Rhythm - Multi-Dataset Urban Activity Analysis</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Mapbox GL JS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.css" rel="stylesheet"/>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js"></script>
    <!-- D3.js, PapaParse, Chart.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- Make sure these script tags are in the right order in your index.html -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- Wait until Chart.js is fully loaded -->
    <script>
    // Check that Chart is available
    if (typeof Chart === 'undefined') {
        console.error('Chart.js not loaded properly!');
    } else {
        console.log('Chart.js loaded successfully');
    }
    </script>
    <!-- Then add the plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1.1/dist/chartjs-chart-matrix.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="styles.css">
</head>
<body class="bg-gray-100 p-4 md:p-8">
    <div class="max-w-7xl mx-auto bg-white p-4 md:p-6 rounded-lg shadow-lg mb-20">
        <h1 class="text-2xl md:text-3xl font-bold text-center mb-2">NYC Urban Rhythm</h1>
        <p class="text-center text-gray-600 mb-4">Analyzing Urban Activity Patterns Across NYC</p>

        <!-- Controls -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 mb-4">
            <div class="p-3 border rounded-lg bg-gray-50">
                <h3 class="font-medium text-sm mb-2">311 Service Requests</h3>
                <input type="file" id="csv311" accept=".csv" multiple class="text-sm mb-1"/>
                <p class="text-xs text-gray-500">Load 311 call data</p>
            </div>
            
            <div class="p-3 border rounded-lg bg-gray-50">
                <h3 class="font-medium text-sm mb-2">MTA Transit Data</h3>
                <input type="file" id="csvMTA" accept=".csv" multiple class="text-sm mb-1"/>
                <p class="text-xs text-gray-500">Load subway ridership data</p>
            </div>
            
            <div class="p-3 border rounded-lg bg-gray-50">
                <h3 class="font-medium text-sm mb-2">TLC Trip Data</h3>
                <input type="file" id="csvTLC" accept=".csv" multiple class="text-sm mb-1"/>
                <p class="text-xs text-gray-500">Load taxi/rideshare data</p>
            </div>
            
            <div class="p-3 border rounded-lg bg-gray-50">
                <h3 class="font-medium text-sm mb-2">NYC Events</h3>
                <input type="file" id="csvEvents" accept=".csv" multiple class="text-sm mb-1"/>
                <p class="text-xs text-gray-500">Load event permit data</p>
            </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-3 mb-4 items-end justify-center">
            <div class="flex gap-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Start Date:</label>
                    <input type="date" id="startDate" disabled class="text-sm"/>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">End Date:</label>
                    <input type="date" id="endDate" disabled class="text-sm"/>
                </div>
            </div>
            <button id="updateDashboardBtn" disabled class="px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm whitespace-nowrap">
                Update Dashboard
            </button>
        </div>

        <!-- Timeline Control -->
        <div id="timeline-control" class="mb-4 p-3 border rounded-lg bg-gray-50 hidden">
            <div class="flex justify-between items-center mb-2">
                <h3 class="font-medium">Timeline</h3>
                <div class="flex gap-2">
                    <button id="hourly-view" class="px-2 py-1 text-xs bg-blue-100 rounded">Hourly</button>
                    <button id="daily-view" class="px-2 py-1 text-xs bg-gray-200 rounded">Daily</button>
                    <button id="weekly-view" class="px-2 py-1 text-xs bg-gray-200 rounded">Weekly</button>
                    <button id="monthly-view" class="px-2 py-1 text-xs bg-gray-200 rounded">Monthly</button>
                </div>
            </div>
            <div id="timeline-slider-container" class="h-12"></div>
        </div>

        <!-- Tabs -->
        <div class="border-b border-gray-200 mb-4">
            <ul class="flex flex-wrap text-center">
                <li class="mr-2">
                    <button id="tab-map" class="tab-active inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Map View
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-trends" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Trend Analysis
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-categories" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Service Requests
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-transit" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Transit
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-taxi" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Taxi Trips
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-events" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Events
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-correlation" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Correlations
                    </button>
                </li>
                <li class="mr-2">
                    <button id="tab-weather" class="inline-block p-3 rounded-t-lg hover:bg-gray-50">
                        Weather
                    </button>
                </li>
            </ul>
        </div>

        <!-- Tab Content -->
        <div class="tab-content">
            <!-- Map Tab -->
            <div id="content-map" class="tab-pane">
                <div class="relative">
                    <div id="map" class="rounded-lg mb-4"></div>
                    <div id="tooltip"></div>
                    <div id="loading-overlay">
                        <div class="spinner"></div>
                        <span id="loading-text" class="ml-2 text-gray-700">Loading...</span>
                    </div>
                    <div id="legend" class="legend absolute bottom-4 right-4 hidden"></div>
                    
                    <!-- Layer Controls -->
                    <div class="absolute top-4 right-4 bg-white p-2 rounded-lg shadow border">
                        <h4 class="text-sm font-medium mb-2">Layers</h4>
                        <div class="flex flex-col gap-1">
                            <label class="flex items-center text-xs">
                                <input type="checkbox" id="layer-311" checked class="mr-1">
                                311 Calls
                            </label>
                            <label class="flex items-center text-xs">
                                <input type="checkbox" id="layer-transit" class="mr-1">
                                Transit Stations
                            </label>
                            <label class="flex items-center text-xs">
                                <input type="checkbox" id="layer-taxi" class="mr-1">
                                Taxi Activity
                            </label>
                            <label class="flex items-center text-xs">
                                <input type="checkbox" id="layer-events" class="mr-1">
                                Events
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Trend Analysis Tab -->
            <div id="content-trends" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Activity Over Time</h3>
                        <div class="chart-container">
                            <canvas id="trends-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Activity by Day of Week</h3>
                        <div class="chart-container">
                            <canvas id="dow-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Activity by Hour of Day</h3>
                        <div class="chart-container">
                            <canvas id="hour-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Borough Proportion Over Time</h3>
                        <div class="chart-container">
                            <canvas id="proportion-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Service Requests Tab -->
            <div id="content-categories" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Top Complaint Types</h3>
                        <div id="categories-list" class="h-80 overflow-y-auto"></div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Complaint Breakdown by Borough</h3>
                        <div class="chart-container h-80">
                            <canvas id="categories-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Transit Tab -->
            <div id="content-transit" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Ridership by Borough</h3>
                        <div class="chart-container">
                            <canvas id="transit-borough-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Ridership by Time of Day</h3>
                        <div class="chart-container">
                            <canvas id="transit-time-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border col-span-2">
                        <h3 class="text-lg font-semibold mb-2">Top Transit Stations</h3>
                        <div id="top-stations" class="grid grid-cols-2 lg:grid-cols-3 gap-3 h-40 overflow-y-auto"></div>
                    </div>
                </div>
            </div>

            <!-- Taxi Trips Tab -->
            <div id="content-taxi" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Trip Volume by Time</h3>
                        <div class="chart-container">
                            <canvas id="taxi-time-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Average Trip Distance</h3>
                        <div class="chart-container">
                            <canvas id="taxi-distance-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border col-span-2">
                        <h3 class="text-lg font-semibold mb-2">Popular Pickup/Dropoff Zones</h3>
                        <div class="chart-container h-40">
                            <canvas id="taxi-locations-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Events Tab -->
            <div id="content-events" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Events by Borough</h3>
                        <div class="chart-container">
                            <canvas id="events-borough-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Events by Type</h3>
                        <div class="chart-container">
                            <canvas id="events-type-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border col-span-2">
                        <h3 class="text-lg font-semibold mb-2">Upcoming/Recent Events</h3>
                        <div id="events-list" class="h-40 overflow-y-auto"></div>
                    </div>
                </div>
            </div>

            <!-- Correlations Tab -->
            <div id="content-correlation" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Transit vs 311 Calls</h3>
                        <div class="chart-container">
                            <canvas id="transit-311-chart"></canvas>
                        </div>
                    </div>
                    <!-- <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Events vs Nearby Activity</h3>
                        <div class="chart-container">
                            <canvas id="events-impact-chart"></canvas>
                        </div>
                    </div> -->
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Taxi Trips vs 311 Calls</h3>
                        <div class="chart-container">
                            <canvas id="taxi-311-chart"></canvas>
                        </div>
                    </div>
                    <!-- <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Activity Correlation Matrix</h3>
                        <div class="chart-container">
                            <canvas id="correlation-matrix"></canvas>
                        </div>
                    </div> -->
                </div>
            </div>

            <!-- Weather Correlation Tab -->
            <div id="content-weather" class="tab-pane hidden">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Temperature vs. Activity</h3>
                        <div class="chart-container">
                            <canvas id="temp-correlation"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border">
                        <h3 class="text-lg font-semibold mb-2">Precipitation vs. Activity</h3>
                        <div class="chart-container">
                            <canvas id="precip-correlation"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow border col-span-2">
                        <h3 class="text-lg font-semibold mb-2">Weather-Sensitive Activities</h3>
                        <div id="weather-findings" class="text-sm text-gray-700 max-h-48 overflow-y-auto"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div id="info-panel" class="mt-4 p-4 bg-gray-50 text-sm text-gray-600 rounded-lg">
            <div id="info-text">Load data files, pick date range, then click Update Dashboard.</div>
            <div id="stats-summary" class="mt-2 hidden">
                <div class="font-medium">Quick Stats:</div>
                <div class="flex flex-wrap gap-4 mt-1">
                    <div id="stat-311" class="px-3 py-1 bg-blue-100 rounded-full text-blue-800"></div>
                    <div id="stat-transit" class="px-3 py-1 bg-green-100 rounded-full text-green-800"></div>
                    <div id="stat-taxi" class="px-3 py-1 bg-amber-100 rounded-full text-amber-800"></div>
                    <div id="stat-events" class="px-3 py-1 bg-purple-100 rounded-full text-purple-800"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="config.js"></script>
    <script src="utils.js"></script>
    <script src="dataLoader.js"></script>
    <script src="dataProcessor.js"></script>
    <script src="mapVisualization.js"></script>
    <script src="timelineControls.js"></script>
    <script src="charts.js"></script>
    <script src="weatherCorrelation.js"></script>
    <script src="eventAnalysis.js"></script>
    <script src="transitAnalysis.js"></script>
    <script src="taxiAnalysis.js"></script>
    <script src="correlationDashboard.js"></script>
    <script src="main.js"></script>
</body>
</html>

================================================================================

FILE: main.js
LINES: 275
--------------------------------------------------------------------------------

/**
 * Main application logic for NYC Urban Rhythm
 */

// Initialize application on document load
document.addEventListener('DOMContentLoaded', () => {
    // Initialize components
    initializeMap();
    initializeDataLoaders();
    initializeCharts();
    initializeTimelineControls();
    
    // Set up update button handler
    document.getElementById('updateDashboardBtn').addEventListener('click', updateDashboard);
    
    // Set up tab switching
    setupTabs();
});

/**
 * Set up tab switching
 */
function setupTabs() {
    const tabs = {
        map: document.getElementById('tab-map'),
        trends: document.getElementById('tab-trends'),
        categories: document.getElementById('tab-categories'),
        transit: document.getElementById('tab-transit'),
        taxi: document.getElementById('tab-taxi'),
        events: document.getElementById('tab-events'),
        correlation: document.getElementById('tab-correlation'),
        weather: document.getElementById('tab-weather')
    };
    
    const contents = {
        map: document.getElementById('content-map'),
        trends: document.getElementById('content-trends'),
        categories: document.getElementById('content-categories'),
        transit: document.getElementById('content-transit'),
        taxi: document.getElementById('content-taxi'),
        events: document.getElementById('content-events'),
        correlation: document.getElementById('content-correlation'),
        weather: document.getElementById('content-weather')
    };
    
    // Set up tab click handlers
    Object.keys(tabs).forEach(tabKey => {
        tabs[tabKey].addEventListener('click', () => {
            // Update active tab
            Object.values(tabs).forEach(tab => {
                tab.classList.remove('tab-active');
            });
            tabs[tabKey].classList.add('tab-active');
            
            // Update visible content
            Object.values(contents).forEach(content => {
                content.classList.add('hidden');
            });
            contents[tabKey].classList.remove('hidden');
            
            // Special handling for map tab
            if (tabKey === 'map') {
                // Trigger map resize to fix rendering issues
                map.resize();
            }
        });
    });
}

/**
 * Update dashboard with current data
 */
async function updateDashboard() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    // Validate date range
    if (!startDate || !endDate || startDate > endDate) {
        updateInfoText('Invalid date range.');
        return;
    }
    
    // Disable controls during update
    document.getElementById('startDate').disabled = true;
    document.getElementById('endDate').disabled = true;
    document.getElementById('updateDashboardBtn').disabled = true;
    
    // Show loading indicator
    showLoading('Processing data & updating visualizations...');
    
    try {
        // Get datasets filtered by date range
        const filteredData = getFilteredDatasets(startDate, endDate);
        
        // Process all data
        processAllData(startDate, endDate, filteredData);
        
        // Fetch and add weather data if possible
        try {
            const weatherData = await fetchWeatherData(startDate, endDate);
            processedData.weather = weatherData;
        } catch (e) {
            console.error('Error fetching weather data:', e);
            processedData.weather = {};
        }
        
        // Calculate correlations
        processedData.correlations = {
            transitVs311: {},
            taxiVs311: {},
            eventsImpact: []
        };
        
        // Update visualizations
        updateMapVisualization();
        updateAllCharts();
        
        // Update stats summary
        const stats = getDatasetStats(filteredData);
        updateStatsSummary(stats);
        
        // Calculate and store correlations
        const correlations = calculateAllCorrelations();
        
        // Update correlation dashboard
        updateCorrelationDashboard(correlations);
        
        // Update info text
        updateInfoText(`Dashboard updated with data from ${startDate} to ${endDate}.`);
    } catch (error) {
        console.error('Error updating dashboard:', error);
        updateInfoText('Error updating dashboard. Please try again.');
    } finally {
        // Hide loading indicator
        hideLoading();
        
        // Re-enable controls
        document.getElementById('startDate').disabled = false;
        document.getElementById('endDate').disabled = false;
        document.getElementById('updateDashboardBtn').disabled = false;
    }
}

/**
 * Update time-filtered visualizations based on current timeline state
 */
function updateTimeBasedVisualizations() {
    const timeMark = timelineState.timeMarks[timelineState.selectedTimeIndex];
    if (!timeMark) return;
    
    // Create appropriate filter based on timeline mode
    let filteredData;
    
    switch (timelineState.mode) {
        case 'hourly':
            // Filter for specific hour
            filteredData = filterDataForHour(timeMark.date, timeMark.hour);
            break;
            
        case 'daily':
            // Filter for specific date
            filteredData = filterDataForDay(timeMark.date);
            break;
            
        case 'weekly':
            // Filter for week range
            filteredData = filterDataForDateRange(timeMark.date, timeMark.endDate);
            break;
            
        case 'monthly':
            // Filter for month
            const year = parseInt(timeMark.date.substring(0, 4));
            const month = parseInt(timeMark.date.substring(5, 7)) - 1;
            const startDate = new Date(year, month, 1);
            const endDate = new Date(year, month + 1, 0);
            
            filteredData = filterDataForDateRange(
                formatDate(startDate),
                formatDate(endDate)
            );
            break;
    }
    
    // Update visualizations with filtered data
    updateTimeFilteredVisualizations(filteredData, timeMark);
}

/**
 * Update visualizations with time-filtered data
 * @param {Object} filteredData - Filtered data 
 * @param {Object} timeMark - Current time mark
 */
function updateTimeFilteredVisualizations(filteredData, timeMark) {
    // Process filtered data
    const tempProcessed = {
        calls311: {},
        transit: {},
        taxi: {},
        events: {},
        weather: processedData.weather
    };
    
    // Save original processed data
    const originalProcessed = processedData;
    
    // Process 311 data
    if (filteredData.calls311.length > 0) {
        process311Data(filteredData.calls311);
        tempProcessed.calls311 = processedData.calls311;
    }
    
    // Process transit data
    if (filteredData.transit.length > 0) {
        processTransitData(filteredData.transit);
        tempProcessed.transit = processedData.transit;
    }
    
    // Process taxi data
    if (filteredData.taxi.length > 0) {
        processTaxiData(filteredData.taxi);
        tempProcessed.taxi = processedData.taxi;
    }
    
    // Process events data
    if (filteredData.events.length > 0) {
        processEventsData(filteredData.events);
        tempProcessed.events = processedData.events;
    }
    
    // Set processed data to filtered data
    processedData = tempProcessed;
    
    // Update map visualization
    updateMapVisualization();
    
    // Update info text
    let timeText = '';
    
    switch (timelineState.mode) {
        case 'hourly':
            timeText = `${timeMark.date} at ${timeMark.hour}:00`;
            break;
            
        case 'daily':
            timeText = timeMark.date;
            break;
            
        case 'weekly':
            timeText = `week of ${timeMark.date}`;
            break;
            
        case 'monthly':
            timeText = timeMark.label;
            break;
    }
    
    updateInfoText(`Showing data for ${timeText}`);
    
    // Count records in each dataset
    const counts = {
        calls311: filteredData.calls311.length,
        transit: filteredData.transit.reduce((sum, item) => sum + (parseFloat(item.ridership) || 0), 0),
        taxi: filteredData.taxi.length,
        events: filteredData.events.length
    };
    
    // Update stats
    document.getElementById('stat-311').textContent = `311 Calls: ${formatNumber(counts.calls311)}`;
    document.getElementById('stat-transit').textContent = `Subway Entries: ${formatNumber(Math.round(counts.transit))}`;
    document.getElementById('stat-taxi').textContent = `Taxi Trips: ${formatNumber(counts.taxi)}`;
    document.getElementById('stat-events').textContent = `Events: ${formatNumber(counts.events)}`;
    
    // Restore original processed data
    processedData = originalProcessed;
}

================================================================================

FILE: mapVisualization.js
LINES: 634
--------------------------------------------------------------------------------

/**
 * Map visualization functionality for NYC Urban Rhythm
 */

// Map instance
let map;

// Layer references
let markers = {
    transit: [],
    events: [],
    taxi: []
};

// Cluster markers
let clusterMarkers = [];

/**
 * Initialize the map
 */
function initializeMap() {
    // Initialize map with Mapbox
    mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;
    
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/light-v10',
        center: [-73.985, 40.748],
        zoom: 9.5,
        maxBounds: [[-74.3, 40.45], [-73.6, 40.95]]
    });
    
    // Add navigation controls
    map.addControl(new mapboxgl.NavigationControl());
    
    // Set up event handlers
    map.on('load', async () => {
        showLoading('Loading borough boundaries...');
        
        try {
            // Load borough boundaries
            const response = await fetch(GEOJSON_URL);
            const geojson = await response.json();
            
            // Add source
            map.addSource('boroughs', { 
                type: 'geojson', 
                data: geojson 
            });
            
            // Add fill layer
            map.addLayer({
                id: 'borough-fill',
                type: 'fill',
                source: 'boroughs',
                paint: { 
                    'fill-color': '#ccc', 
                    'fill-opacity': 0.6, 
                    'fill-outline-color': '#fff' 
                }
            });
            
            // Add line layer
            map.addLayer({
                id: 'borough-line',
                type: 'line',
                source: 'boroughs',
                paint: { 
                    'line-color': '#444', 
                    'line-width': 1.5 
                }
            });
            
            // Add hover layer
            map.addLayer({
                id: 'borough-hover',
                type: 'fill',
                source: 'boroughs',
                paint: { 
                    'fill-color': '#444', 
                    'fill-opacity': 0.3 
                },
                filter: ['==', ['get', 'name'], '']
            });
            
            // Set up hover effects
            setupBoroughHoverEffects();
        } catch (error) {
            console.error('Error loading borough boundaries:', error);
            updateInfoText('Error loading borough boundaries.');
        } finally {
            hideLoading();
        }
    });
    
    // Set up layer toggle handlers
    setupLayerToggles();
}

/**
 * Set up borough hover effects
 */
function setupBoroughHoverEffects() {
    // Popup for hover info
    const popup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false,
        maxWidth: '240px'
    });
    
    // Track hovered feature ID
    let hoveredFeatureId = null;
    
    // Mouse move handler
    map.on('mousemove', 'borough-fill', e => {
        if (!e.features.length) return;
        
        const feature = e.features[0];
        
        // Only update if we're hovering a new feature
        if (hoveredFeatureId !== feature.id) {
            hoveredFeatureId = feature.id;
            
            // Update hover filter
            map.setFilter('borough-hover', ['==', ['get', 'name'], feature.properties.name]);
            
            // Update cursor
            map.getCanvas().style.cursor = 'pointer';
            
            // Create popup content based on processed data
            let html = `<div class="font-medium text-sm">${feature.properties.name}</div>`;
            
            // Add 311 call data if available
            if (processedData.calls311.totalByBorough) {
                const calls = processedData.calls311.totalByBorough[feature.properties.name] || 0;
                html += `<div class="text-xs"><span class="data-indicator indicator-311"></span>311 Calls: ${formatNumber(calls)}</div>`;
            }
            
            // Add transit data if available
            if (processedData.transit.ridershipByBorough) {
                const ridership = processedData.transit.ridershipByBorough[feature.properties.name] || 0;
                html += `<div class="text-xs"><span class="data-indicator indicator-transit"></span>Subway Entries: ${formatNumber(Math.round(ridership))}</div>`;
            }
            
            // Add taxi data if available
            if (processedData.taxi.pickupsByBorough) {
                const pickups = processedData.taxi.pickupsByBorough[feature.properties.name] || 0;
                html += `<div class="text-xs"><span class="data-indicator indicator-taxi"></span>Taxi Pickups: ${formatNumber(pickups)}</div>`;
            }
            
            // Add events data if available
            if (processedData.events.eventsByBorough) {
                const events = processedData.events.eventsByBorough[feature.properties.name] || 0;
                html += `<div class="text-xs"><span class="data-indicator indicator-event"></span>Events: ${formatNumber(events)}</div>`;
            }
            
            // Show popup
            popup.setLngLat(e.lngLat)
                .setHTML(html)
                .addTo(map);
        }
    });
    
    // Mouse leave handler
    map.on('mouseleave', 'borough-fill', () => {
        hoveredFeatureId = null;
        map.setFilter('borough-hover', ['==', ['get', 'name'], '']);
        map.getCanvas().style.cursor = '';
        popup.remove();
    });
    
    // Click handler
    map.on('click', 'borough-fill', e => {
        if (!e.features.length) return;
        
        const feature = e.features[0];
        const boroughName = feature.properties.name;
        
        // Fly to borough
        map.flyTo({
            center: BOROUGH_CENTROIDS[boroughName],
            zoom: 11,
            duration: 1000
        });
        
        // Create a pulse effect
        createPulseEffect(map, BOROUGH_CENTROIDS[boroughName], BOROUGH_COLORS[boroughName]);
    });
}

/**
 * Set up layer toggle handlers
 */
function setupLayerToggles() {
    // 311 calls layer toggle
    document.getElementById('layer-311').addEventListener('change', e => {
        map.setPaintProperty(
            'borough-fill', 
            'fill-opacity', 
            e.target.checked ? 0.6 : 0
        );
    });
    
    // Transit layer toggle
    document.getElementById('layer-transit').addEventListener('change', e => {
        markers.transit.forEach(marker => {
            marker.getElement().style.display = e.target.checked ? 'block' : 'none';
        });
    });
    
    // Taxi layer toggle
    document.getElementById('layer-taxi').addEventListener('change', e => {
        if (map.getLayer('taxi-heatmap')) {
            map.setLayoutProperty(
                'taxi-heatmap',
                'visibility',
                e.target.checked ? 'visible' : 'none'
            );
        }
    });
    
    // Events layer toggle
    document.getElementById('layer-events').addEventListener('change', e => {
        markers.events.forEach(marker => {
            marker.getElement().style.display = e.target.checked ? 'block' : 'none';
        });
    });
}

/**
 * Update map visualization based on processed data
 */
function updateMapVisualization() {
    // Clear existing markers
    clearAllMarkers();
    
    // Update 311 calls visualization
    update311CallsLayer();
    
    // Update transit stations
    updateTransitStations();
    
    // Update taxi heatmap
    updateTaxiHeatmap();
    
    // Update events markers
    updateEventsMarkers();
    
    // Update activity clusters
    updateActivityClusters();
    
    // Update legend
    updateMapLegend();
}

/**
 * Clear all markers from the map
 */
function clearAllMarkers() {
    // Remove transit markers
    markers.transit.forEach(marker => marker.remove());
    markers.transit = [];
    
    // Remove event markers
    markers.events.forEach(marker => marker.remove());
    markers.events = [];
    
    // Remove taxi layer if it exists
    if (map.getLayer('taxi-heatmap')) {
        map.removeLayer('taxi-heatmap');
    }
    
    if (map.getSource('taxi-points')) {
        map.removeSource('taxi-points');
    }
    
    // Remove cluster markers
    clusterMarkers.forEach(marker => marker.remove());
    clusterMarkers = [];
}

/**
 * Update 311 calls layer
 */
function update311CallsLayer() {
    if (!processedData.calls311.totalByBorough) return;
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const maxCalls = Math.max(...validBoroughs.map(b => processedData.calls311.totalByBorough[b] || 0), 1);
    const colorScale = d3.scaleSequential(d3.interpolateBlues).domain([0, maxCalls]);
    
    // Create expression for borough fill color
    const expression = ['match', ['get', 'name']];
    
    validBoroughs.forEach(borough => {
        const calls = processedData.calls311.totalByBorough[borough] || 0;
        expression.push(borough, colorScale(calls));
    });
    
    // Default color
    expression.push('#ccc');
    
    // Update borough fill color
    map.setPaintProperty('borough-fill', 'fill-color', expression);
}

/**
 * Update transit station markers
 */
function updateTransitStations() {
    // Check if we have station data
    if (!processedData.transit.stationRidership) return;
    
    // Only show top stations to avoid cluttering the map
    const stations = Object.values(processedData.transit.stationRidership)
        .filter(station => station.lat && station.lng)
        .sort((a, b) => b.total - a.total)
        .slice(0, 30);
    
    // Create marker for each station
    stations.forEach(station => {
        const el = createMarkerElement('transit');
        
        // Create popup content
        const popupContent = `
            <div class="font-medium text-sm">${station.id}: ${station.borough}</div>
            <div class="text-xs">Entries: ${formatNumber(Math.round(station.total))}</div>
        `;
        
        // Create popup
        const popup = new mapboxgl.Popup({ offset: 10 })
            .setHTML(popupContent);
        
        // Create and add marker
        const marker = new mapboxgl.Marker({ element: el })
            .setLngLat([station.lng, station.lat])
            .setPopup(popup)
            .addTo(map);
        
        // Store reference
        markers.transit.push(marker);
        
        // Hide if transit layer is disabled
        if (!document.getElementById('layer-transit').checked) {
            el.style.display = 'none';
        }
    });
}

/**
 * Update taxi heatmap
 */
function updateTaxiHeatmap() {
    // Check if we have taxi data
    if (!processedData.taxi.pickupsByBorough) return;
    
    // Since we don't have exact coordinates for all taxi pickups,
    // we'll create a simulated heatmap based on borough activity
    const points = [];
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    validBoroughs.forEach(borough => {
        const pickups = processedData.taxi.pickupsByBorough[borough] || 0;
        
        // Skip if no pickups
        if (pickups === 0) return;
        
        // Get borough center
        const [lat, lng] = BOROUGH_CENTROIDS[borough];
        
        // Create a number of points proportional to pickup count
        // We'll distribute them randomly around the borough center
        const numPoints = Math.min(Math.ceil(pickups / 10), 100);
        
        for (let i = 0; i < numPoints; i++) {
            // Add random offset to create a spread
            const latOffset = (Math.random() - 0.5) * 0.05;
            const lngOffset = (Math.random() - 0.5) * 0.05;
            
            points.push({
                type: 'Feature',
                properties: {
                    intensity: pickups / numPoints
                },
                geometry: {
                    type: 'Point',
                    coordinates: [lng + lngOffset, lat + latOffset]
                }
            });
        }
    });
    
    // Add source if we have points
    if (points.length > 0) {
        // Add source
        map.addSource('taxi-points', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: points
            }
        });
        
        // Add heatmap layer
        map.addLayer({
            id: 'taxi-heatmap',
            type: 'heatmap',
            source: 'taxi-points',
            paint: {
                'heatmap-weight': ['get', 'intensity'],
                'heatmap-intensity': 0.6,
                'heatmap-color': [
                    'interpolate',
                    ['linear'],
                    ['heatmap-density'],
                    0, 'rgba(236,222,239,0)',
                    0.2, 'rgb(250,219,134)',
                    0.4, 'rgb(245,186,82)',
                    0.6, 'rgb(238,150,33)',
                    0.8, 'rgb(232,114,14)',
                    1, 'rgb(204,80,16)'
                ],
                'heatmap-radius': 15,
                'heatmap-opacity': 0.7
            },
            layout: {
                visibility: document.getElementById('layer-taxi').checked ? 'visible' : 'none'
            }
        });
    }
}

/**
 * Update events markers
 */
function updateEventsMarkers() {
    // Check if we have events data
    if (!processedData.events.eventsList) return;
    
    // Create marker for each event
    processedData.events.eventsList.forEach(event => {
        // Skip if no coordinates
        if (!event.lat || !event.lng) return;
        
        const el = createMarkerElement('event', 16);
        
        // Create popup content
        const startDate = new Date(event.start);
        const formattedDate = startDate.toLocaleDateString();
        const popupContent = `
            <div class="font-medium text-sm">${event.name}</div>
            <div class="text-xs">${formattedDate}</div>
            <div class="text-xs">${event.borough}</div>
            <div class="text-xs">${event.type || 'No type specified'}</div>
        `;
        
        // Create popup
        const popup = new mapboxgl.Popup({ offset: 10 })
            .setHTML(popupContent);
        
        // Create and add marker
        const marker = new mapboxgl.Marker({ element: el })
            .setLngLat([event.lng, event.lat])
            .setPopup(popup)
            .addTo(map);
        
        // Store reference
        markers.events.push(marker);
        
        // Hide if events layer is disabled
        if (!document.getElementById('layer-events').checked) {
            el.style.display = 'none';
        }
    });
}

/**
 * Update activity clusters
 */
function updateActivityClusters() {
    // Detect clusters
    const clusters = detectActivityClusters();
    
    // Add cluster markers
    clusters.slice(0, 10).forEach(cluster => {
        // Create element for cluster
        const el = document.createElement('div');
        el.className = 'flex items-center justify-center rounded-full border-2 border-white shadow-md';
        el.style.width = '30px';
        el.style.height = '30px';
        el.style.fontSize = '10px';
        el.style.fontWeight = 'bold';
        el.style.color = 'white';
        
        // Set color based on dominant type
        let color = '#666';
        if (cluster.dominant === 'calls311') color = DATASET_COLORS.calls311;
        else if (cluster.dominant === 'transit') color = DATASET_COLORS.transit;
        else if (cluster.dominant === 'taxi') color = DATASET_COLORS.taxi;
        else if (cluster.dominant === 'event') color = DATASET_COLORS.events;
        
        el.style.backgroundColor = color;
        el.textContent = cluster.pointCount;
        
        // Create popup content
        let typesText = '';
        Object.entries(cluster.types).forEach(([type, count]) => {
            const pct = Math.round((count / cluster.pointCount) * 100);
            typesText += `<div class="text-xs">${type}: ${count} (${pct}%)</div>`;
        });
        
        const popupContent = `
            <div class="font-medium text-sm">Activity Cluster</div>
            <div class="text-xs">Total Points: ${cluster.pointCount}</div>
            ${typesText}
        `;
        
        // Create popup
        const popup = new mapboxgl.Popup({ offset: 15 })
            .setHTML(popupContent);
        
        // Create and add marker
        const marker = new mapboxgl.Marker({ element: el })
            .setLngLat([cluster.center.lng, cluster.center.lat])
            .setPopup(popup)
            .addTo(map);
        
        // Store reference
        clusterMarkers.push(marker);
    });
}

/**
 * Update map legend
 */
function updateMapLegend() {
    const legend = document.getElementById('legend');
    legend.innerHTML = '<h4 class="font-semibold text-xs mb-1">Data Layers</h4>';
    legend.classList.remove('hidden');
    
    // 311 calls legend
    if (processedData.calls311.totalByBorough) {
        const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
        const maxCalls = Math.max(...validBoroughs.map(b => processedData.calls311.totalByBorough[b] || 0), 1);
        const colorScale = d3.scaleSequential(d3.interpolateBlues).domain([0, maxCalls]);
        
        const section = document.createElement('div');
        section.className = 'mt-2';
        section.innerHTML = '<div class="text-xs font-medium">311 Calls</div>';
        
        // Create color steps
        const steps = 4;
        const stepSize = maxCalls / steps;
        
        for (let i = 0; i < steps; i++) {
            const low = Math.round(i * stepSize);
            const high = Math.round((i + 1) * stepSize);
            const color = colorScale(low + stepSize / 2);
            
            const item = document.createElement('div');
            item.className = 'legend-item text-xs';
            item.innerHTML = `
                <span class="legend-color" style="background-color:${color}"></span>
                <span>${formatNumber(low)}–${formatNumber(high)}</span>
            `;
            
            section.appendChild(item);
        }
        
        legend.appendChild(section);
    }
    
    // Transit stations legend
    if (markers.transit.length > 0) {
        const section = document.createElement('div');
        section.className = 'mt-2';
        section.innerHTML = `
            <div class="text-xs font-medium">Transit Stations</div>
            <div class="legend-item text-xs">
                <div class="marker-transit" style="width:10px;height:10px;"></div>
                <span class="ml-1">Top stations by ridership</span>
            </div>
        `;
        
        legend.appendChild(section);
    }
    
    // Taxi heatmap legend
    if (map.getLayer('taxi-heatmap')) {
        const section = document.createElement('div');
        section.className = 'mt-2';
        section.innerHTML = `
            <div class="text-xs font-medium">Taxi Activity</div>
            <div class="legend-item text-xs">
                <div class="flex h-2">
                    <div style="width:30px;background:linear-gradient(to right,rgb(250,219,134),rgb(204,80,16))"></div>
                </div>
                <span class="ml-1">Pickup density</span>
            </div>
        `;
        
        legend.appendChild(section);
    }
    
    // Events legend
    if (markers.events.length > 0) {
        const section = document.createElement('div');
        section.className = 'mt-2';
        section.innerHTML = `
            <div class="text-xs font-medium">Events</div>
            <div class="legend-item text-xs">
                <div class="marker-event" style="width:12px;height:12px;"></div>
                <span class="ml-1">Event locations</span>
            </div>
        `;
        
        legend.appendChild(section);
    }
    
    // Clusters legend
    if (clusterMarkers.length > 0) {
        const section = document.createElement('div');
        section.className = 'mt-2';
        section.innerHTML = `
            <div class="text-xs font-medium">Activity Clusters</div>
            <div class="legend-item text-xs">
                <div style="width:12px;height:12px;border-radius:50%;background-color:#666;color:white;font-size:8px;text-align:center;line-height:12px;">N</div>
                <span class="ml-1">N points of activity</span>
            </div>
        `;
        
        legend.appendChild(section);
    }
}

================================================================================

FILE: styles.css
LINES: 226
--------------------------------------------------------------------------------

/* General styling */
body { 
    font-family: 'Inter', sans-serif;
    height: 100vh;
    overflow-x: hidden;
}

input[type="file"], input[type="date"] { 
    padding: 0.5rem; 
}

/* Map styling */
#map { 
    height: 400px; 
    width: 100%; 
}

.legend { 
    max-height: 150px; 
    overflow-y: auto; 
    background: rgba(255,255,255,0.9); 
    padding: 0.75rem; 
    border-radius: 0.5rem; 
}

.legend-item { 
    display: flex; 
    align-items: center; 
    margin-bottom: 0.25rem; 
}

.legend-color { 
    width: 15px; 
    height: 15px; 
    margin-right: 0.5rem; 
    border: 1px solid #ccc; 
}

/* Loading overlay */
#loading-overlay { 
    position: absolute; 
    top: 0; 
    left: 0; 
    right: 0; 
    bottom: 0; 
    background: rgba(255,255,255,0.8); 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    visibility: hidden; 
    z-index: 1000; 
}

.spinner { 
    border: 4px solid rgba(0,0,0,0.1); 
    width: 36px; 
    height: 36px; 
    border-radius: 50%; 
    border-left-color: #09f; 
    animation: spin 1s linear infinite; 
}

@keyframes spin { 
    to { transform: rotate(360deg); } 
}

/* UI states */
button:disabled { 
    opacity: 0.6; 
    cursor: not-allowed; 
}

.tab-active { 
    background-color: #EFF6FF; 
    border-bottom: 2px solid #3B82F6; 
}

.category-item { 
    cursor: pointer; 
}

.category-item:hover { 
    background-color: #F3F4F6; 
}

.category-item.selected { 
    background-color: #DBEAFE; 
}

/* Chart containers */
.chart-container {
    height: 220px;
    max-height: 220px;
    position: relative;
}

.tab-content {
    height: calc(100vh - 240px);
    max-height: calc(100vh - 240px);
    overflow-y: auto;
}

/* Tooltip styling */
#tooltip {
    position: absolute;
    background: white;
    padding: 10px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    display: none;
    z-index: 1000;
    max-width: 300px;
}

#tooltip::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: white transparent transparent transparent;
}

/* Timeline slider styling */
#timeline-slider-container {
    position: relative;
}

.time-mark {
    position: absolute;
    width: 3px;
    background-color: rgba(59, 130, 246, 0.5);
    bottom: 0;
    cursor: pointer;
}

.time-mark:hover {
    background-color: rgb(59, 130, 246);
}

.time-mark.selected {
    background-color: rgb(59, 130, 246);
    width: 5px;
}

.time-label {
    position: absolute;
    font-size: 9px;
    color: #666;
    white-space: nowrap;
    transform: rotate(-45deg);
    transform-origin: left top;
    margin-top: 2px;
}

.time-axis {
    position: absolute;
    height: 1px;
    background-color: #ddd;
    bottom: 0;
    width: 100%;
}

/* Data type markers and events */
.marker-transit {
    width: 12px;
    height: 12px;
    background-color: #10B981;
    border-radius: 50%;
    border: 2px solid white;
}

.marker-event {
    width: 14px;
    height: 14px;
    background-color: #8B5CF6;
    border-radius: 50%;
    border: 2px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
}

.marker-event::after {
    content: 'E';
    color: white;
    font-size: 8px;
    font-weight: bold;
}

.pulse-circle {
    width: 30px;
    height: 30px;
    background-color: rgba(59, 130, 246, 0.3);
    border-radius: 50%;
    position: absolute;
    animation: pulse 1.5s infinite;
    pointer-events: none;
}

@keyframes pulse {
    0% {
        transform: scale(0.5);
        opacity: 1;
    }
    100% {
        transform: scale(1.5);
        opacity: 0;
    }
}

/* Dataset indicator dots */
.data-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 4px;
}

.indicator-311 { background-color: #3B82F6; }
.indicator-transit { background-color: #10B981; }
.indicator-taxi { background-color: #F59E0B; }
.indicator-event { background-color: #8B5CF6; }

================================================================================

FILE: taxiAnalysis.js
LINES: 449
--------------------------------------------------------------------------------

/**
 * Taxi trip analysis functionality for NYC Urban Rhythm
 */

/**
 * Analyze taxi trip patterns
 * @param {Array} taxiData - Taxi trip data
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Object} - Taxi analysis results
 */
function analyzeTaxiPatterns(taxiData, startDate, endDate) {
    // Filter data by date range
    const filteredData = taxiData.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    // Initialize analysis object
    const analysis = {
        totalTrips: filteredData.length,
        byBorough: {
            pickup: {},
            dropoff: {}
        },
        byHour: Array(24).fill(0),
        byDayOfWeek: Array(7).fill(0),
        metrics: {
            avgDistance: 0,
            avgFare: 0,
            avgTip: 0,
            distanceByBorough: {},
            fareByBorough: {}
        },
        originDestination: {}
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Initialize borough counts
    validBoroughs.forEach(borough => {
        analysis.byBorough.pickup[borough] = 0;
        analysis.byBorough.dropoff[borough] = 0;
        analysis.metrics.distanceByBorough[borough] = [];
        analysis.metrics.fareByBorough[borough] = [];
        
        // Initialize origin-destination matrix
        analysis.originDestination[borough] = {};
        validBoroughs.forEach(dest => {
            analysis.originDestination[borough][dest] = 0;
        });
    });
    
    // Analyze data
    filteredData.forEach(record => {
        // Add to hourly count
        analysis.byHour[record.hour]++;
        
        // Add to day of week count
        analysis.byDayOfWeek[record.dow]++;
        
        // Add to pickup borough count
        if (record.pu_borough && analysis.byBorough.pickup[record.pu_borough] !== undefined) {
            analysis.byBorough.pickup[record.pu_borough]++;
            
            // Add to metrics by borough
            analysis.metrics.distanceByBorough[record.pu_borough].push(record.trip_distance);
            analysis.metrics.fareByBorough[record.pu_borough].push(record.fare_amount);
        }
        
        // Add to dropoff borough count
        if (record.do_borough && analysis.byBorough.dropoff[record.do_borough] !== undefined) {
            analysis.byBorough.dropoff[record.do_borough]++;
        }
        
        // Add to origin-destination matrix
        if (record.pu_borough && record.do_borough && 
            analysis.originDestination[record.pu_borough] && 
            analysis.originDestination[record.pu_borough][record.do_borough] !== undefined) {
            analysis.originDestination[record.pu_borough][record.do_borough]++;
        }
        
        // Add to overall metrics
        analysis.metrics.avgDistance += record.trip_distance;
        analysis.metrics.avgFare += record.fare_amount;
        analysis.metrics.avgTip += record.tip_amount;
    });
    
    // Calculate averages
    if (filteredData.length > 0) {
        analysis.metrics.avgDistance /= filteredData.length;
        analysis.metrics.avgFare /= filteredData.length;
        analysis.metrics.avgTip /= filteredData.length;
    }
    
    // Calculate borough averages
    validBoroughs.forEach(borough => {
        const distances = analysis.metrics.distanceByBorough[borough];
        const fares = analysis.metrics.fareByBorough[borough];
        
        analysis.metrics.distanceByBorough[borough] = distances.length > 0 
            ? distances.reduce((sum, val) => sum + val, 0) / distances.length 
            : 0;
            
        analysis.metrics.fareByBorough[borough] = fares.length > 0 
            ? fares.reduce((sum, val) => sum + val, 0) / fares.length 
            : 0;
    });
    
    return analysis;
}

/**
 * Find peak taxi activity periods
 * @param {Object} analysis - Taxi analysis results
 * @returns {Object} - Peak activity periods
 */
function findPeakTaxiPeriods(analysis) {
    // Find peak hour
    let peakHour = 0;
    let peakHourValue = 0;
    
    for (let i = 0; i < 24; i++) {
        if (analysis.byHour[i] > peakHourValue) {
            peakHourValue = analysis.byHour[i];
            peakHour = i;
        }
    }
    
    // Find peak day of week
    let peakDay = 0;
    let peakDayValue = 0;
    
    for (let i = 0; i < 7; i++) {
        if (analysis.byDayOfWeek[i] > peakDayValue) {
            peakDayValue = analysis.byDayOfWeek[i];
            peakDay = i;
        }
    }
    
    // Get peak origin-destination pair
    let peakOD = { origin: null, destination: null, trips: 0 };
    
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    validBoroughs.forEach(origin => {
        validBoroughs.forEach(destination => {
            const trips = analysis.originDestination[origin][destination];
            if (trips > peakOD.trips) {
                peakOD = { origin, destination, trips };
            }
        });
    });
    
    return {
        peakHour,
        peakDay,
        peakOD,
        peakHourValue,
        peakDayValue
    };
}

/**
 * Analyze correlation between taxi trips and 311 calls
 * @param {Object} taxiAnalysis - Taxi analysis results
 * @returns {Object} - Correlation analysis
 */
function analyzeTaxi311Correlation(taxiAnalysis) {
    // Initialize correlation object
    const correlation = {
        overall: null,
        byBorough: {},
        byHour: null,
        byDayOfWeek: null
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Calculate borough-level correlation
    validBoroughs.forEach(borough => {
        // Get daily taxi pickups and 311 calls for this borough
        const taxiSeries = [];
        const callsSeries = [];
        
        // Check if we have daily data for taxi and 311
        if (processedData.taxi.dailyData && processedData.calls311.dailyData) {
            // Get days that exist in both datasets
            const commonDays = Object.keys(processedData.taxi.dailyData).filter(date => 
                processedData.calls311.dailyData[date]
            );
            
            // Build data series
            commonDays.forEach(date => {
                taxiSeries.push(processedData.taxi.dailyData[date].byBorough[borough] || 0);
                callsSeries.push(processedData.calls311.dailyData[date].byBorough[borough] || 0);
            });
            
            // Calculate correlation if we have enough data points
            if (taxiSeries.length >= 3) {
                correlation.byBorough[borough] = calculateCorrelation(taxiSeries, callsSeries);
            }
        }
    });
    
    // Calculate hourly correlation
    if (processedData.taxi.hourlyByBorough && processedData.calls311.hourlyByBorough) {
        // Aggregate hourly data across all boroughs
        const taxiHourly = Array(24).fill(0);
        const callsHourly = Array(24).fill(0);
        
        validBoroughs.forEach(borough => {
            for (let hour = 0; hour < 24; hour++) {
                taxiHourly[hour] += processedData.taxi.hourlyByBorough[borough][hour] || 0;
                callsHourly[hour] += processedData.calls311.hourlyByBorough[borough][hour] || 0;
            }
        });
        
        // Calculate correlation
        correlation.byHour = calculateCorrelation(taxiHourly, callsHourly);
    }
    
    // Calculate day of week correlation
    if (processedData.taxi.dowByBorough && processedData.calls311.dowByBorough) {
        // Aggregate day of week data across all boroughs
        const taxiDOW = Array(7).fill(0);
        const callsDOW = Array(7).fill(0);
        
        validBoroughs.forEach(borough => {
            for (let dow = 0; dow < 7; dow++) {
                taxiDOW[dow] += processedData.taxi.dowByBorough[borough][dow] || 0;
                callsDOW[dow] += processedData.calls311.dowByBorough[borough][dow] || 0;
            }
        });
        
        // Calculate correlation
        correlation.byDayOfWeek = calculateCorrelation(taxiDOW, callsDOW);
    }
    
    return correlation;
}

/**
 * Generate taxi heatmap data
 * @param {Object} analysis - Taxi analysis results
 * @returns {Array} - GeoJSON features for heatmap
 */
function generateTaxiHeatmap(analysis) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const features = [];
    
    // Create points based on borough activity
    validBoroughs.forEach(borough => {
        const pickups = analysis.byBorough.pickup[borough] || 0;
        
        // Skip if no pickups
        if (pickups === 0) return;
        
        // Get borough center
        const [lat, lng] = BOROUGH_CENTROIDS[borough];
        
        // Create proportional number of points
        const numPoints = Math.min(Math.ceil(pickups / 10), 100);
        
        for (let i = 0; i < numPoints; i++) {
            // Add random offset to create a spread
            const latOffset = (Math.random() - 0.5) * 0.05;
            const lngOffset = (Math.random() - 0.5) * 0.05;
            
            features.push({
                type: 'Feature',
                properties: {
                    intensity: pickups / numPoints
                },
                geometry: {
                    type: 'Point',
                    coordinates: [lng + lngOffset, lat + latOffset]
                }
            });
        }
    });
    
    return features;
}

/**
 * Generate origin-destination flow visualization
 * @param {Object} analysis - Taxi analysis results
 * @returns {Array} - Flow lines data
 */
function generateODFlowVisualization(analysis) {
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    const flows = [];
    
    // Create flow lines between boroughs
    validBoroughs.forEach(origin => {
        validBoroughs.forEach(destination => {
            // Skip self-loops
            if (origin === destination) return;
            
            const trips = analysis.originDestination[origin][destination];
            
            // Skip if no trips
            if (trips === 0) return;
            
            // Get borough centers
            const [originLat, originLng] = BOROUGH_CENTROIDS[origin];
            const [destLat, destLng] = BOROUGH_CENTROIDS[destination];
            
            // Calculate width based on trip count
            const maxTrips = Math.max(
                ...validBoroughs.flatMap(o => 
                    validBoroughs.map(d => 
                        analysis.originDestination[o][d]
                    )
                )
            );
            
            const width = Math.max(1, (trips / maxTrips) * 5);
            
            flows.push({
                origin: [originLng, originLat],
                destination: [destLng, destLat],
                trips,
                width,
                color: BOROUGH_COLORS[origin]
            });
        });
    });
    
    // Sort by trip count (to draw smaller flows on top)
    flows.sort((a, b) => b.trips - a.trips);
    
    return flows;
}

/**
 * Update taxi visualization on the map
 * @param {Object} analysis - Taxi analysis results
 */
function updateTaxiMapVisualization(analysis) {
    // Remove existing taxi layer if it exists
    if (map.getLayer('taxi-heatmap')) {
        map.removeLayer('taxi-heatmap');
    }
    
    if (map.getSource('taxi-points')) {
        map.removeSource('taxi-points');
    }
    
    // Generate heatmap data
    const heatmapData = generateTaxiHeatmap(analysis);
    
    // Add source if we have points
    if (heatmapData.length > 0) {
        // Add source
        map.addSource('taxi-points', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: heatmapData
            }
        });
        
        // Add heatmap layer
        map.addLayer({
            id: 'taxi-heatmap',
            type: 'heatmap',
            source: 'taxi-points',
            paint: {
                'heatmap-weight': ['get', 'intensity'],
                'heatmap-intensity': 0.6,
                'heatmap-color': [
                    'interpolate',
                    ['linear'],
                    ['heatmap-density'],
                    0, 'rgba(236,222,239,0)',
                    0.2, 'rgb(250,219,134)',
                    0.4, 'rgb(245,186,82)',
                    0.6, 'rgb(238,150,33)',
                    0.8, 'rgb(232,114,14)',
                    1, 'rgb(204,80,16)'
                ],
                'heatmap-radius': 15,
                'heatmap-opacity': 0.7
            },
            layout: {
                visibility: document.getElementById('layer-taxi').checked ? 'visible' : 'none'
            }
        });
    }
    
    // Add origin-destination flow lines for top flows
    const flows = generateODFlowVisualization(analysis);
    
    // Top 5 flows only
    flows.slice(0, 5).forEach(flow => {
        // Create a curved line between points
        const midpoint = [
            (flow.origin[0] + flow.destination[0]) / 2,
            (flow.origin[1] + flow.destination[1]) / 2 - 0.05
        ];
        
        // Create a GeoJSON line feature with curved path
        const lineData = {
            type: 'Feature',
            properties: {
                trips: flow.trips,
                color: flow.color,
                width: flow.width
            },
            geometry: {
                type: 'LineString',
                coordinates: [
                    flow.origin,
                    midpoint,
                    flow.destination
                ]
            }
        };
        
        // Add source if it doesn't exist
        const sourceId = `od-flow-${flow.origin[0]}-${flow.origin[1]}-${flow.destination[0]}-${flow.destination[1]}`;
        
        if (!map.getSource(sourceId)) {
            map.addSource(sourceId, {
                type: 'geojson',
                data: lineData
            });
            
            // Add line layer
            map.addLayer({
                id: sourceId,
                type: 'line',
                source: sourceId,
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round',
                    visibility: document.getElementById('layer-taxi').checked ? 'visible' : 'none'
                },
                paint: {
                    'line-color': flow.color,
                    'line-width': flow.width,
                    'line-opacity': 0.6
                }
            });
        }
    });
}

================================================================================

FILE: timelineControls.js
LINES: 439
--------------------------------------------------------------------------------

/**
 * Timeline controls functionality for NYC Urban Rhythm
 */

// Current timeline state
let timelineState = {
    mode: 'hourly', // hourly, daily, weekly, monthly
    timeMarks: [],
    selectedTimeIndex: null
};

/**
 * Initialize timeline controls
 */
function initializeTimelineControls() {
    // Set up view mode buttons
    document.getElementById('hourly-view').addEventListener('click', () => setTimelineMode('hourly'));
    document.getElementById('daily-view').addEventListener('click', () => setTimelineMode('daily'));
    document.getElementById('weekly-view').addEventListener('click', () => setTimelineMode('weekly'));
    document.getElementById('monthly-view').addEventListener('click', () => setTimelineMode('monthly'));
}

/**
 * Set timeline mode
 * @param {string} mode - Timeline mode (hourly, daily, weekly, monthly)
 */
function setTimelineMode(mode) {
    // Update active button
    const buttons = ['hourly-view', 'daily-view', 'weekly-view', 'monthly-view'];
    buttons.forEach(id => {
        const button = document.getElementById(id);
        button.className = button.id === `${mode}-view` 
            ? 'px-2 py-1 text-xs bg-blue-100 rounded' 
            : 'px-2 py-1 text-xs bg-gray-200 rounded';
    });
    
    // Update state
    timelineState.mode = mode;
    
    // Update timeline
    updateTimeline();
}

/**
 * Update timeline based on processed data and current mode
 */
function updateTimeline() {
    const container = document.getElementById('timeline-slider-container');
    container.innerHTML = '';
    
    // Add time axis
    const axis = document.createElement('div');
    axis.className = 'time-axis';
    container.appendChild(axis);
    
    // Get data based on current mode
    const startDate = new Date(document.getElementById('startDate').value);
    const endDate = new Date(document.getElementById('endDate').value);
    
    // Generate time marks based on mode
    timelineState.timeMarks = generateTimeMarks(timelineState.mode, startDate, endDate);
    
    // Create time marks
    timelineState.timeMarks.forEach((mark, index) => {
        // Create mark element
        const markElement = document.createElement('div');
        markElement.className = 'time-mark';
        markElement.style.height = '8px';
        
        // Position based on index
        const position = (index / (timelineState.timeMarks.length - 1)) * 100;
        markElement.style.left = `${position}%`;
        
        // Set intensity based on activity level
        let intensity = 0;
        
        // Sum activity across datasets
        if (processedData.calls311.dailyData && processedData.calls311.dailyData[mark.date]) {
            intensity += processedData.calls311.dailyData[mark.date].total;
        }
        
        if (processedData.transit.dailyData && processedData.transit.dailyData[mark.date]) {
            // Scale down transit numbers to be comparable to 311
            intensity += processedData.transit.dailyData[mark.date].total * 0.1;
        }
        
        if (processedData.taxi.dailyData && processedData.taxi.dailyData[mark.date]) {
            intensity += processedData.taxi.dailyData[mark.date].total;
        }
        
        // Normalize intensity
        const normalizedIntensity = Math.min(Math.log10(intensity + 1) / 4, 1);
        markElement.style.height = `${8 + (normalizedIntensity * 12)}px`;
        
        // Set up click handler
        markElement.addEventListener('click', () => selectTimeMark(index));
        
        // Add tooltip
        markElement.title = mark.label;
        
        // Add to container
        container.appendChild(markElement);
        
        // Add label to select marks
        if (index % Math.max(1, Math.floor(timelineState.timeMarks.length / 10)) === 0 || 
            index === timelineState.timeMarks.length - 1) {
            const label = document.createElement('div');
            label.className = 'time-label';
            label.textContent = mark.label;
            label.style.left = `${position}%`;
            container.appendChild(label);
        }
    });
    
    // Select first time mark by default
    if (timelineState.timeMarks.length > 0 && timelineState.selectedTimeIndex === null) {
        selectTimeMark(0);
    }
}

/**
 * Generate time marks based on mode and date range
 * @param {string} mode - Timeline mode
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {Array} - Array of time marks
 */
function generateTimeMarks(mode, startDate, endDate) {
    const marks = [];
    
    switch (mode) {
        case 'hourly':
            // For hourly view, we'll show one day with 24 hours
            const currentDate = new Date(startDate);
            
            for (let hour = 0; hour < 24; hour++) {
                currentDate.setHours(hour, 0, 0, 0);
                
                marks.push({
                    date: formatDate(currentDate),
                    hour: hour,
                    label: `${hour}:00`,
                    timestamp: currentDate.getTime()
                });
            }
            break;
            
        case 'daily':
            // For daily view, we'll show days in the range
            const daily = new Date(startDate);
            
            while (daily <= endDate) {
                marks.push({
                    date: formatDate(daily),
                    label: daily.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }),
                    timestamp: daily.getTime()
                });
                
                daily.setDate(daily.getDate() + 1);
            }
            break;
            
        case 'weekly':
            // For weekly view, we'll show weeks in the range
            const weekly = new Date(startDate);
            
            // Move to the start of the week (Sunday)
            const dayOfWeek = weekly.getDay();
            weekly.setDate(weekly.getDate() - dayOfWeek);
            
            while (weekly <= endDate) {
                const weekEnd = new Date(weekly);
                weekEnd.setDate(weekEnd.getDate() + 6);
                
                marks.push({
                    date: formatDate(weekly),
                    endDate: formatDate(weekEnd),
                    label: `${weekly.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} - ${weekEnd.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}`,
                    timestamp: weekly.getTime()
                });
                
                weekly.setDate(weekly.getDate() + 7);
            }
            break;
            
        case 'monthly':
            // For monthly view, we'll show months in the range
            const monthly = new Date(startDate);
            
            // Move to the start of the month
            monthly.setDate(1);
            
            while (monthly <= endDate) {
                marks.push({
                    date: `${monthly.getFullYear()}-${String(monthly.getMonth() + 1).padStart(2, '0')}-01`,
                    label: monthly.toLocaleDateString(undefined, { month: 'long', year: 'numeric' }),
                    timestamp: monthly.getTime()
                });
                
                monthly.setMonth(monthly.getMonth() + 1);
            }
            break;
    }
    
    return marks;
}

/**
 * Select a time mark
 * @param {number} index - Index of time mark to select
 */
function selectTimeMark(index) {
    // Validate index
    if (index < 0 || index >= timelineState.timeMarks.length) return;
    
    // Update state
    timelineState.selectedTimeIndex = index;
    
    // Update UI
    const container = document.getElementById('timeline-slider-container');
    const marks = container.querySelectorAll('.time-mark');
    
    marks.forEach((mark, i) => {
        mark.classList.toggle('selected', i === index);
    });
    
    // Trigger time-based filtering
    updateTimeBasedVisualization(timelineState.timeMarks[index]);
}

/**
 * Update visualizations based on selected time
 * @param {Object} timeMark - Selected time mark
 */
function updateTimeBasedVisualization(timeMark) {
    // Filter data based on selected time
    let filteredData;
    
    switch (timelineState.mode) {
        case 'hourly':
            // Filter for specific hour on specific date
            filteredData = filterDataForHour(timeMark.date, timeMark.hour);
            break;
            
        case 'daily':
            // Filter for specific date
            filteredData = filterDataForDay(timeMark.date);
            break;
            
        case 'weekly':
            // Filter for date range (week)
            filteredData = filterDataForDateRange(timeMark.date, timeMark.endDate);
            break;
            
        case 'monthly':
            // Filter for month
            const year = parseInt(timeMark.date.substring(0, 4));
            const month = parseInt(timeMark.date.substring(5, 7)) - 1;
            const startDate = new Date(year, month, 1);
            const endDate = new Date(year, month + 1, 0);
            
            filteredData = filterDataForDateRange(
                formatDate(startDate),
                formatDate(endDate)
            );
            break;
    }
    
    // Update visualizations with filtered data
    if (filteredData) {
        updateTimeFilteredVisualization(filteredData, timeMark);
    }
}

/**
 * Filter data for specific hour on specific date
 * @param {string} date - Date in YYYY-MM-DD format
 * @param {number} hour - Hour (0-23)
 * @returns {Object} - Filtered data
 */
function filterDataForHour(date, hour) {
    return {
        calls311: all311Data.filter(item => 
            item.parsed_date === date && item.hour === hour
        ),
        transit: transitData.filter(item => 
            item.parsed_date === date && item.hour === hour
        ),
        taxi: taxiData.filter(item => 
            item.parsed_date === date && item.hour === hour
        ),
        events: eventsData.filter(item => {
            if (item.parsed_date !== date) return false;
            
            // Check if event is active during this hour
            const startHour = new Date(item.start_datetime).getHours();
            const endHour = new Date(item.end_datetime).getHours();
            
            return hour >= startHour && hour <= endHour;
        })
    };
}

/**
 * Filter data for specific date
 * @param {string} date - Date in YYYY-MM-DD format
 * @returns {Object} - Filtered data
 */
function filterDataForDay(date) {
    return {
        calls311: all311Data.filter(item => item.parsed_date === date),
        transit: transitData.filter(item => item.parsed_date === date),
        taxi: taxiData.filter(item => item.parsed_date === date),
        events: eventsData.filter(item => item.parsed_date === date)
    };
}

/**
 * Filter data for date range
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Object} - Filtered data
 */
function filterDataForDateRange(startDate, endDate) {
    return {
        calls311: all311Data.filter(item => 
            item.parsed_date >= startDate && item.parsed_date <= endDate
        ),
        transit: transitData.filter(item => 
            item.parsed_date >= startDate && item.parsed_date <= endDate
        ),
        taxi: taxiData.filter(item => 
            item.parsed_date >= startDate && item.parsed_date <= endDate
        ),
        events: eventsData.filter(item => {
            const itemDate = new Date(item.parsed_date);
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            return itemDate >= start && itemDate <= end;
        })
    };
}

/**
 * Update visualizations with time-filtered data
 * @param {Object} filteredData - Filtered data
 * @param {Object} timeMark - Selected time mark
 */
function updateTimeFilteredVisualization(filteredData, timeMark) {
    // Process filtered data
    const tempProcessed = {
        calls311: {},
        transit: {},
        taxi: {},
        events: {},
        weather: processedData.weather // Keep existing weather data
    };
    
    // Process each dataset
    if (filteredData.calls311.length > 0) {
        process311Data(filteredData.calls311);
        tempProcessed.calls311 = processedData.calls311;
    }
    
    if (filteredData.transit.length > 0) {
        processTransitData(filteredData.transit);
        tempProcessed.transit = processedData.transit;
    }
    
    if (filteredData.taxi.length > 0) {
        processTaxiData(filteredData.taxi);
        tempProcessed.taxi = processedData.taxi;
    }
    
    if (filteredData.events.length > 0) {
        processEventsData(filteredData.events);
        tempProcessed.events = processedData.events;
    }
    
    // Store original processed data
    const originalProcessed = processedData;
    
    // Set processed data to filtered data
    processedData = tempProcessed;
    
    // Update map visualization
    updateMapVisualization();
    
    // Update info text
    updateTimeFilteredInfoText(filteredData, timeMark);
    
    // Restore original processed data
    processedData = originalProcessed;
}

/**
 * Update info text for time-filtered visualization
 * @param {Object} filteredData - Filtered data
 * @param {Object} timeMark - Selected time mark
 */
function updateTimeFilteredInfoText(filteredData, timeMark) {
    let timeText = '';
    
    switch (timelineState.mode) {
        case 'hourly':
            timeText = `${timeMark.date} at ${timeMark.hour}:00`;
            break;
            
        case 'daily':
            timeText = timeMark.date;
            break;
            
        case 'weekly':
            timeText = `week of ${timeMark.date}`;
            break;
            
        case 'monthly':
            timeText = timeMark.label;
            break;
    }
    
    // Count records in each dataset
    const counts = {
        calls311: filteredData.calls311.length,
        transit: filteredData.transit.reduce((sum, item) => sum + (parseFloat(item.ridership) || 0), 0),
        taxi: filteredData.taxi.length,
        events: filteredData.events.length
    };
    
    // Update stats
    document.getElementById('stat-311').textContent = `311 Calls: ${formatNumber(counts.calls311)}`;
    document.getElementById('stat-transit').textContent = `Subway Entries: ${formatNumber(Math.round(counts.transit))}`;
    document.getElementById('stat-taxi').textContent = `Taxi Trips: ${formatNumber(counts.taxi)}`;
    document.getElementById('stat-events').textContent = `Events: ${formatNumber(counts.events)}`;
    
    // Update info text
    updateInfoText(`Showing data for ${timeText}`);
}

================================================================================

FILE: transitAnalysis.js
LINES: 352
--------------------------------------------------------------------------------

/**
 * Transit analysis functionality for NYC Urban Rhythm
 */

/**
 * Analyze transit ridership patterns
 * @param {Array} transitData - Transit ridership data
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Object} - Transit analysis results
 */
function analyzeTransitPatterns(transitData, startDate, endDate) {
    // Filter data by date range
    const filteredData = transitData.filter(item => 
        item.parsed_date >= startDate && item.parsed_date <= endDate
    );
    
    // Initialize analysis object
    const analysis = {
        totalRidership: 0,
        byBorough: {},
        byStation: {},
        byHour: Array(24).fill(0),
        byDayOfWeek: Array(7).fill(0),
        byFareType: {}
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Initialize borough counts
    validBoroughs.forEach(borough => {
        analysis.byBorough[borough] = 0;
    });
    
    // Analyze data
    filteredData.forEach(record => {
        const ridership = parseFloat(record.ridership) || 0;
        
        // Add to total
        analysis.totalRidership += ridership;
        
        // Add to borough total
        if (analysis.byBorough[record.borough] !== undefined) {
            analysis.byBorough[record.borough] += ridership;
        }
        
        // Add to station total
        if (!analysis.byStation[record.station_complex]) {
            analysis.byStation[record.station_complex] = {
                id: record.station_complex_id,
                total: 0,
                byHour: Array(24).fill(0),
                lat: record.lat,
                lng: record.lng,
                borough: record.borough
            };
        }
        analysis.byStation[record.station_complex].total += ridership;
        
        // Add to hourly total
        analysis.byHour[record.hour] += ridership;
        
        // Add to day of week total
        analysis.byDayOfWeek[record.dow] += ridership;
        
        // Add to fare type total
        const fareType = record.payment_method || 'Unknown';
        if (!analysis.byFareType[fareType]) {
            analysis.byFareType[fareType] = 0;
        }
        analysis.byFareType[fareType] += ridership;
        
        // Also track station hourly patterns
        analysis.byStation[record.station_complex].byHour[record.hour] += ridership;
    });
    
    return analysis;
}

/**
 * Find transit "hotspots" - stations with unusually high ridership
 * @param {Object} analysis - Transit analysis results
 * @returns {Array} - Transit hotspots
 */
function findTransitHotspots(analysis) {
    // Get stations sorted by total ridership
    const stations = Object.entries(analysis.byStation)
        .map(([name, data]) => ({ name, ...data }))
        .filter(station => station.lat && station.lng) // Only include stations with coordinates
        .sort((a, b) => b.total - a.total);
    
    // Calculate average ridership
    const totalStations = stations.length;
    const totalRidership = stations.reduce((sum, station) => sum + station.total, 0);
    const avgRidership = totalStations > 0 ? totalRidership / totalStations : 0;
    
    // Find hotspots (stations with ridership > 2x average)
    const hotspots = stations.filter(station => station.total > avgRidership * 2);
    
    return hotspots;
}

/**
 * Analyze correlation between transit ridership and 311 calls
 * @param {Object} transitAnalysis - Transit analysis results
 * @returns {Object} - Correlation analysis
 */
function analyzeTransit311Correlation(transitAnalysis) {
    // Initialize correlation object
    const correlation = {
        overall: null,
        byBorough: {},
        byHour: null,
        byDayOfWeek: null,
        stationProximity: []
    };
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Calculate borough-level correlation
    validBoroughs.forEach(borough => {
        // Get daily transit ridership and 311 calls for this borough
        const transitSeries = [];
        const callsSeries = [];
        
        // Check if we have daily data for transit and 311
        if (processedData.transit.dailyData && processedData.calls311.dailyData) {
            // Get days that exist in both datasets
            const commonDays = Object.keys(processedData.transit.dailyData).filter(date => 
                processedData.calls311.dailyData[date]
            );
            
            // Build data series
            commonDays.forEach(date => {
                transitSeries.push(processedData.transit.dailyData[date].byBorough[borough] || 0);
                callsSeries.push(processedData.calls311.dailyData[date].byBorough[borough] || 0);
            });
            
            // Calculate correlation if we have enough data points
            if (transitSeries.length >= 3) {
                correlation.byBorough[borough] = calculateCorrelation(transitSeries, callsSeries);
            }
        }
    });
    
    // Calculate hourly correlation
    if (processedData.transit.hourlyByBorough && processedData.calls311.hourlyByBorough) {
        // Aggregate hourly data across all boroughs
        const transitHourly = Array(24).fill(0);
        const callsHourly = Array(24).fill(0);
        
        validBoroughs.forEach(borough => {
            for (let hour = 0; hour < 24; hour++) {
                transitHourly[hour] += processedData.transit.hourlyByBorough[borough][hour] || 0;
                callsHourly[hour] += processedData.calls311.hourlyByBorough[borough][hour] || 0;
            }
        });
        
        // Calculate correlation
        correlation.byHour = calculateCorrelation(transitHourly, callsHourly);
    }
    
    // Calculate day of week correlation
    if (processedData.transit.dowByBorough && processedData.calls311.dowByBorough) {
        // Aggregate day of week data across all boroughs
        const transitDOW = Array(7).fill(0);
        const callsDOW = Array(7).fill(0);
        
        validBoroughs.forEach(borough => {
            for (let dow = 0; dow < 7; dow++) {
                transitDOW[dow] += processedData.transit.dowByBorough[borough][dow] || 0;
                callsDOW[dow] += processedData.calls311.dowByBorough[borough][dow] || 0;
            }
        });
        
        // Calculate correlation
        correlation.byDayOfWeek = calculateCorrelation(transitDOW, callsDOW);
    }
    
    // Analyze station proximity correlation
    // Check if we have station data and 311 data with coordinates
    if (transitAnalysis.byStation && all311Data && all311Data.length > 0) {
        // Get top stations
        const topStations = Object.entries(transitAnalysis.byStation)
            .map(([name, data]) => ({ name, ...data }))
            .filter(station => station.lat && station.lng)
            .sort((a, b) => b.total - a.total)
            .slice(0, 10);
        
        // For each station, count nearby 311 calls
        topStations.forEach(station => {
            // Count 311 calls within 500 meters
            const nearbyCalls = all311Data.filter(call => {
                if (!call.lat || !call.lng) return false;
                
                const distance = calculateDistance(
                    station.lat, station.lng,
                    call.lat, call.lng
                );
                
                return distance <= 500; // 500 meters radius
            }).length;
            
            correlation.stationProximity.push({
                station: station.name,
                ridership: station.total,
                nearbyCalls,
                ratio: station.total > 0 ? nearbyCalls / station.total : 0
            });
        });
        
        // Sort by ratio
        correlation.stationProximity.sort((a, b) => b.ratio - a.ratio);
    }
    
    return correlation;
}

/**
 * Generate transit heatmap data
 * @param {Object} analysis - Transit analysis results
 * @returns {Array} - GeoJSON features for heatmap
 */
function generateTransitHeatmap(analysis) {
    // Convert station data to GeoJSON points
    const features = [];
    
    Object.entries(analysis.byStation).forEach(([name, data]) => {
        if (!data.lat || !data.lng) return;
        
        features.push({
            type: 'Feature',
            properties: {
                name,
                ridership: data.total,
                borough: data.borough
            },
            geometry: {
                type: 'Point',
                coordinates: [data.lng, data.lat]
            }
        });
    });
    
    return features;
}

/**
 * Generate transit flow visualization
 * @param {Object} analysis - Transit analysis results
 * @returns {Object} - Flow visualization data
 */
function generateTransitFlowVisualization(analysis) {
    // Initialize hours data
    const hourlyData = Array(24).fill().map((_, i) => ({
        hour: i,
        total: 0,
        byBorough: {}
    }));
    
    // Get valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Initialize borough values
    validBoroughs.forEach(borough => {
        hourlyData.forEach(hour => {
            hour.byBorough[borough] = 0;
        });
    });
    
    // Aggregate hourly data by borough
    if (processedData.transit.hourlyByBorough) {
        validBoroughs.forEach(borough => {
            for (let hour = 0; hour < 24; hour++) {
                const ridership = processedData.transit.hourlyByBorough[borough][hour] || 0;
                hourlyData[hour].byBorough[borough] = ridership;
                hourlyData[hour].total += ridership;
            }
        });
    }
    
    // Find peak and low hours
    const peakHour = [...hourlyData].sort((a, b) => b.total - a.total)[0]?.hour || 8;
    const lowHour = [...hourlyData].sort((a, b) => a.total - b.total)[0]?.hour || 3;
    
    // Generate visualization data
    return {
        hourlyData,
        peakHour,
        lowHour,
        stations: Object.entries(analysis.byStation)
            .map(([name, data]) => ({ name, ...data }))
            .filter(station => station.lat && station.lng)
            .sort((a, b) => b.total - a.total)
            .slice(0, 30)
    };
}

/**
 * Update transit visualization on the map
 * @param {Object} analysis - Transit analysis results
 */
function updateTransitMapVisualization(analysis) {
    // Clear existing transit markers
    markers.transit.forEach(marker => marker.remove());
    markers.transit = [];
    
    // Add top station markers
    const stations = Object.entries(analysis.byStation)
        .map(([name, data]) => ({ name, ...data }))
        .filter(station => station.lat && station.lng)
        .sort((a, b) => b.total - a.total)
        .slice(0, 30);
    
    // Create marker for each station
    stations.forEach(station => {
        const el = createMarkerElement('transit');
        
        // Scale marker size based on ridership
        const maxRidership = stations[0].total;
        const scale = 0.5 + (station.total / maxRidership) * 1.5;
        el.style.width = `${12 * scale}px`;
        el.style.height = `${12 * scale}px`;
        
        // Create popup content
        const popupContent = `
            <div class="font-medium text-sm">${station.name}</div>
            <div class="text-xs">${station.borough}</div>
            <div class="text-xs">Entries: ${formatNumber(Math.round(station.total))}</div>
        `;
        
        // Create popup
        const popup = new mapboxgl.Popup({ offset: 10 })
            .setHTML(popupContent);
        
        // Create and add marker
        const marker = new mapboxgl.Marker({ element: el })
            .setLngLat([station.lng, station.lat])
            .setPopup(popup)
            .addTo(map);
        
        // Store reference
        markers.transit.push(marker);
        
        // Hide if transit layer is disabled
        if (!document.getElementById('layer-transit').checked) {
            el.style.display = 'none';
        }
    });
}

================================================================================

FILE: utils.js
LINES: 239
--------------------------------------------------------------------------------

/**
 * Utility functions for NYC Urban Rhythm application
 */

// Date and time formatting helpers
function formatDate(date) {
    return date.toISOString().split('T')[0];
}

function formatDateTime(date) {
    return date.toISOString().replace('T', ' ').substring(0, 19);
}

function parseDateFlexible(raw) {
    if (!raw) return null;
    // Handle different date formats
    const d = new Date(raw.replace(' ', 'T'));
    return isNaN(d) ? null : d;
}

function getTimeOfDay(hour) {
    if (hour >= 5 && hour < 12) return 'Morning';
    if (hour >= 12 && hour < 17) return 'Afternoon';
    if (hour >= 17 && hour < 21) return 'Evening';
    return 'Night';
}

function getDayOfWeekName(dayIndex) {
    return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayIndex];
}

function getMonthName(monthIndex) {
    return ['January', 'February', 'March', 'April', 'May', 'June', 
            'July', 'August', 'September', 'October', 'November', 'December'][monthIndex];
}

// UI helpers
function showLoading(message) {
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');
    loadingText.textContent = message || 'Loading...';
    loadingOverlay.style.visibility = 'visible';
}

function hideLoading() {
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.visibility = 'hidden';
}

function updateInfoText(message) {
    const infoText = document.getElementById('info-text');
    infoText.textContent = message;
}

function createPulseEffect(map, lngLat, color = '#3B82F6') {
    // Create a pulse effect on the map at the given coordinates
    const el = document.createElement('div');
    el.className = 'pulse-circle';
    el.style.backgroundColor = `${color}40`; // 40 for 25% opacity
    el.style.borderColor = color;
    
    const marker = new mapboxgl.Marker({ element: el })
        .setLngLat(lngLat)
        .addTo(map);
    
    // Remove after animation completes
    setTimeout(() => {
        marker.remove();
    }, 2000);
}

// Data transformation helpers
function groupByBorough(data, boroughKey = 'borough') {
    return data.reduce((acc, item) => {
        const borough = item[boroughKey];
        if (!acc[borough]) acc[borough] = [];
        acc[borough].push(item);
        return acc;
    }, {});
}

function groupByTimeUnit(data, dateKey, timeUnit = 'day') {
    return data.reduce((acc, item) => {
        let key;
        const date = new Date(item[dateKey]);
        
        switch (timeUnit) {
            case 'hour':
                key = `${formatDate(date)}-${date.getHours()}`;
                break;
            case 'day':
                key = formatDate(date);
                break;
            case 'week':
                // Get ISO week number
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
                const week = Math.floor((d.getTime() - new Date(d.getFullYear(), 0, 4).getTime()) / 86400000 / 7) + 1;
                key = `${date.getFullYear()}-W${week.toString().padStart(2, '0')}`;
                break;
            case 'month':
                key = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                break;
            default:
                key = formatDate(date);
        }
        
        if (!acc[key]) acc[key] = [];
        acc[key].push(item);
        return acc;
    }, {});
}

// Calculate correlation between two arrays
function calculateCorrelation(x, y) {
    if (x.length !== y.length) {
        throw new Error('Arrays must have the same length');
    }
    
    const n = x.length;
    
    // Calculate the sums
    let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY = 0;
    for (let i = 0; i < n; i++) {
        sumX += x[i];
        sumY += y[i];
        sumXY += x[i] * y[i];
        sumXX += x[i] * x[i];
        sumYY += y[i] * y[i];
    }
    
    // Calculate Pearson correlation coefficient
    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
    
    if (denominator === 0) return 0;
    return numerator / denominator;
}

// Distance calculation (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth radius in meters
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Distance in meters
}

// Find nearby items within a radius in meters
function findNearbyItems(lat, lon, items, radiusMeters = 500) {
    return items.filter(item => {
        if (!item.latitude || !item.longitude) return false;
        const distance = calculateDistance(
            lat, lon, 
            parseFloat(item.latitude), 
            parseFloat(item.longitude)
        );
        return distance <= radiusMeters;
    });
}

// Format large numbers with commas
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Get a deterministic color based on a string
function stringToColor(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    
    let color = '#';
    for (let i = 0; i < 3; i++) {
        const value = (hash >> (i * 8)) & 0xFF;
        color += ('00' + value.toString(16)).substr(-2);
    }
    
    return color;
}

// Create a lookup object from array
function createLookup(array, keyField) {
    return array.reduce((acc, item) => {
        acc[item[keyField]] = item;
        return acc;
    }, {});
}

// Filter datasets by date range
function filterByDateRange(data, dateField, startDate, endDate) {
    return data.filter(item => {
        const date = item[dateField];
        return date >= startDate && date <= endDate;
    });
}

// Get location ID from coordinates
async function getLocationFromLatLng(lat, lng) {
    try {
        const url = `${API_CONFIG.geocodingEndpoint}${lng},${lat}.json?access_token=${MAPBOX_ACCESS_TOKEN}&types=neighborhood,locality,place`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.features && data.features.length > 0) {
            return data.features[0];
        }
        return null;
    } catch (error) {
        console.error('Geocoding error:', error);
        return null;
    }
}

// Create marker element
function createMarkerElement(type, size = 12) {
    const el = document.createElement('div');
    el.className = `marker-${type}`;
    el.style.width = `${size}px`;
    el.style.height = `${size}px`;
    return el;
}

// Generate an HTML tooltip
function generateTooltip(title, content) {
    return `
        <div class="font-medium text-sm">${title}</div>
        <div class="text-xs">${content}</div>
    `;
}

================================================================================

FILE: weatherCorrelation.js
LINES: 451
--------------------------------------------------------------------------------

/**
 * Weather correlation analysis for NYC Urban Rhythm
 */

// Store weather data by borough
let weatherByBorough = {};

/**
 * Fetch weather data from NOAA API through proxy
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Object} - Weather data indexed by date
 */
async function fetchWeatherData(startDate, endDate) {
    showLoading('Fetching weather data...');
    
    try {
        // Initialize weather data
        const weatherData = {};
        
        // Convert string dates to Date objects
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        // Limit to one week to avoid too many requests
        const limitedEnd = new Date(start);
        limitedEnd.setDate(limitedEnd.getDate() + 7);
        const actualEnd = limitedEnd > end ? end : limitedEnd;
        
        // Fetch weather data for each day
        const currentDate = new Date(start);
        while (currentDate <= actualEnd) {
            const dateStr = formatDate(currentDate);
            
            // Fetch for each borough's weather station
            const boroughPromises = Object.entries(WEATHER_STATIONS).map(async ([borough, stationId]) => {
                try {
                    const data = await fetchNOAAStation(stationId, dateStr);
                    
                    if (data) {
                        if (!weatherByBorough[borough]) {
                            weatherByBorough[borough] = {};
                        }
                        weatherByBorough[borough][dateStr] = data;
                        
                        // Add to master weather data if not already present
                        if (!weatherData[dateStr]) {
                            weatherData[dateStr] = data;
                        }
                    }
                } catch (e) {
                    console.error(`Error fetching weather for ${borough} on ${dateStr}:`, e);
                }
            });
            
            await Promise.all(boroughPromises);
            
            // Move to next day
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        return weatherData;
    } catch (error) {
        console.error('Error fetching weather data:', error);
        updateInfoText('Weather data unavailable. Using 311 data only.');
        return {};
    } finally {
        hideLoading();
    }
}

/**
 * Fetch weather data for a specific station and date
 * @param {string} stationId - NOAA station ID
 * @param {string} date - Date in YYYY-MM-DD format
 * @returns {Object|null} - Weather data or null if error
 */
async function fetchNOAAStation(stationId, date) {
    try {
        const url = `${API_CONFIG.weatherProxy}?station=${stationId}&date=${date}`;
        const response = await fetch(url);
        
        if (!response.ok) return null;
        
        const { results = [] } = await response.json();
        
        return {
            tmax: results.find(r => r.datatype === 'TMAX')?.value || null,
            tmin: results.find(r => r.datatype === 'TMIN')?.value || null,
            prcp: results.find(r => r.datatype === 'PRCP')?.value || 0,
            date
        };
    } catch (error) {
        console.error('Weather fetch error:', error);
        return null;
    }
}

/**
 * Analyze correlation between weather and urban activity
 * @param {Object} weatherData - Weather data by date
 * @returns {Object} - Weather correlation analysis
 */
function analyzeWeatherCorrelation(weatherData) {
    // Store correlation analysis
    const analysis = {
        temperature: {
            overall: null,
            byBorough: {},
            byComplaint: {}
        },
        precipitation: {
            overall: null,
            byBorough: {},
            byComplaint: {}
        }
    };
    
    // Valid boroughs
    const validBoroughs = Object.keys(BOROUGH_CENTROIDS);
    
    // Analyze overall temperature correlation
    const tempPoints = [];
    Object.entries(weatherData).forEach(([date, data]) => {
        if (data.tmax === null || !processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
        
        tempPoints.push({
            temp: data.tmax,
            calls: processedData.calls311.dailyData[date].total
        });
    });
    
    if (tempPoints.length >= 3) {
        const tempX = tempPoints.map(p => p.temp);
        const tempY = tempPoints.map(p => p.calls);
        analysis.temperature.overall = calculateCorrelation(tempX, tempY);
    }
    
    // Analyze overall precipitation correlation
    const precipPoints = [];
    Object.entries(weatherData).forEach(([date, data]) => {
        if (data.prcp === null || !processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
        
        precipPoints.push({
            prcp: data.prcp,
            calls: processedData.calls311.dailyData[date].total
        });
    });
    
    if (precipPoints.length >= 3) {
        const precipX = precipPoints.map(p => p.prcp);
        const precipY = precipPoints.map(p => p.calls);
        analysis.precipitation.overall = calculateCorrelation(precipX, precipY);
    }
    
    // Analyze by borough
    validBoroughs.forEach(borough => {
        // Temperature correlation
        const boroughTempPoints = [];
        Object.entries(weatherData).forEach(([date, data]) => {
            if (data.tmax === null || !processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
            
            boroughTempPoints.push({
                temp: data.tmax,
                calls: processedData.calls311.dailyData[date].byBorough[borough] || 0
            });
        });
        
        if (boroughTempPoints.length >= 3) {
            const boroughTempX = boroughTempPoints.map(p => p.temp);
            const boroughTempY = boroughTempPoints.map(p => p.calls);
            analysis.temperature.byBorough[borough] = calculateCorrelation(boroughTempX, boroughTempY);
        }
        
        // Precipitation correlation
        const boroughPrecipPoints = [];
        Object.entries(weatherData).forEach(([date, data]) => {
            if (data.prcp === null || !processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
            
            boroughPrecipPoints.push({
                prcp: data.prcp,
                calls: processedData.calls311.dailyData[date].byBorough[borough] || 0
            });
        });
        
        if (boroughPrecipPoints.length >= 3) {
            const boroughPrecipX = boroughPrecipPoints.map(p => p.prcp);
            const boroughPrecipY = boroughPrecipPoints.map(p => p.calls);
            analysis.precipitation.byBorough[borough] = calculateCorrelation(boroughPrecipX, boroughPrecipY);
        }
    });
    
    // Analyze by complaint type
    if (processedData.calls311.complaintTypes) {
        // Get top complaint types
        const topComplaints = Object.entries(processedData.calls311.complaintTypes)
            .sort((a, b) => b[1].total - a[1].total)
            .slice(0, 10)
            .map(([complaint]) => complaint);
        
        // Temperature correlation by complaint
        topComplaints.forEach(complaint => {
            const complaintTempData = [];
            
            // Count complaints by date and temperature
            all311Data.forEach(call => {
                if (call.complaint !== complaint) return;
                
                const date = call.parsed_date;
                if (!weatherData[date] || weatherData[date].tmax === null) return;
                
                complaintTempData.push({
                    temp: weatherData[date].tmax,
                    count: 1
                });
            });
            
            // Group by temperature rounded to nearest 5 degrees
            const groupedByTemp = {};
            complaintTempData.forEach(data => {
                const roundedTemp = Math.round(data.temp / 5) * 5;
                if (!groupedByTemp[roundedTemp]) groupedByTemp[roundedTemp] = 0;
                groupedByTemp[roundedTemp] += data.count;
            });
            
            // Calculate correlation if we have enough data points
            const temps = Object.keys(groupedByTemp).map(t => parseInt(t));
            const counts = Object.values(groupedByTemp);
            
            if (temps.length >= 3) {
                analysis.temperature.byComplaint[complaint] = calculateCorrelation(temps, counts);
            }
        });
        
        // Precipitation correlation by complaint
        topComplaints.forEach(complaint => {
            // Count on rainy vs non-rainy days
            let rainyDayCount = 0, rainyDayTotal = 0;
            let dryDayCount = 0, dryDayTotal = 0;
            
            Object.entries(weatherData).forEach(([date, data]) => {
                if (data.prcp === null) return;
                
                const isRainy = data.prcp > 0.1;
                const complaintCount = all311Data.filter(call => 
                    call.parsed_date === date && call.complaint === complaint
                ).length;
                
                if (isRainy) {
                    rainyDayCount++;
                    rainyDayTotal += complaintCount;
                } else {
                    dryDayCount++;
                    dryDayTotal += complaintCount;
                }
            });
            
            // Calculate average per day
            const rainyAvg = rainyDayCount > 0 ? rainyDayTotal / rainyDayCount : 0;
            const dryAvg = dryDayCount > 0 ? dryDayTotal / dryDayCount : 0;
            
            // Calculate ratio
            const ratio = Math.max(rainyAvg, dryAvg) / Math.max(0.1, Math.min(rainyAvg, dryAvg));
            const diff = Math.abs(rainyAvg - dryAvg);
            
            if (rainyDayCount > 0 && dryDayCount > 0) {
                analysis.precipitation.byComplaint[complaint] = {
                    rainyAvg,
                    dryAvg,
                    ratio,
                    diff,
                    moreFrequent: rainyAvg > dryAvg ? 'rainy' : 'dry'
                };
            }
        });
    }
    
    return analysis;
}

/**
 * Find weather-sensitive complaint types
 * @returns {string} - HTML string with findings
 */
function findWeatherSensitiveComplaints() {
    // Temperature ranges for analysis
    const tempRanges = [
        { name: 'Cold', min: -20, max: 40 },
        { name: 'Cool', min: 40, max: 60 },
        { name: 'Mild', min: 60, max: 75 },
        { name: 'Warm', min: 75, max: 85 },
        { name: 'Hot', min: 85, max: 110 }
    ];
    
    // Complaint counters
    const complaintsByTemp = {};
    const complaintsByPrec = { 'Rainy': {}, 'Dry': {} };
    
    // Analyze by temperature
    Object.entries(processedData.weather).forEach(([date, data]) => {
        if (!processedData.calls311.dailyData || !processedData.calls311.dailyData[date]) return;
        
        // Process by temperature
        if (data.tmax !== null) {
            const range = tempRanges.find(r => data.tmax >= r.min && data.tmax < r.max);
            if (range) {
                // Get complaints for this day
                const dayComplaints = {};
                
                all311Data.forEach(call => {
                    if (call.parsed_date === date) {
                        if (!dayComplaints[call.complaint]) dayComplaints[call.complaint] = 0;
                        dayComplaints[call.complaint]++;
                    }
                });
                
                // Add to temperature categories
                Object.entries(dayComplaints).forEach(([complaint, count]) => {
                    if (!complaintsByTemp[complaint]) {
                        complaintsByTemp[complaint] = tempRanges.reduce((acc, r) => {
                            acc[r.name] = { count: 0, days: 0 };
                            return acc;
                        }, {});
                    }
                    
                    complaintsByTemp[complaint][range.name].count += count;
                    complaintsByTemp[complaint][range.name].days += 1;
                });
            }
        }
        
        // Process by precipitation
        if (data.prcp !== null) {
            const isRainy = data.prcp > 0.1;
            const category = isRainy ? 'Rainy' : 'Dry';
            
            all311Data.forEach(call => {
                if (call.parsed_date === date) {
                    if (!complaintsByPrec[category][call.complaint]) {
                        complaintsByPrec[category][call.complaint] = 0;
                    }
                    complaintsByPrec[category][call.complaint]++;
                }
            });
        }
    });
    
    // Find temperature-sensitive complaints
    const tempSensitive = Object.entries(complaintsByTemp)
        .map(([complaint, ranges]) => {
            // Calculate complaint frequency per day for each temperature range
            const frequencies = Object.entries(ranges).map(([range, data]) => {
                return { range, freq: data.days > 0 ? data.count / data.days : 0 };
            });
            
            // Find min and max frequency
            const freqValues = frequencies.map(f => f.freq);
            const minFreq = Math.min(...freqValues);
            const maxFreq = Math.max(...freqValues);
            
            // Calculate the relative spread
            const spread = minFreq > 0 ? maxFreq / minFreq : 0;
            
            return {
                complaint,
                spread,
                frequencies
            };
        })
        .filter(c => c.spread > 1.5 && c.frequencies.some(f => f.freq > 5))
        .sort((a, b) => b.spread - a.spread)
        .slice(0, 5);
    
    // Find precipitation-sensitive complaints
    const precipSensitive = [];
    
    Object.keys(complaintsByPrec.Rainy).forEach(complaint => {
        if (complaintsByPrec.Dry[complaint]) {
            const rainyCount = complaintsByPrec.Rainy[complaint];
            const dryCount = complaintsByPrec.Dry[complaint];
            
            // Get the number of rainy vs dry days
            const rainyDays = Object.entries(processedData.weather)
                .filter(([_, data]) => data.prcp > 0.1)
                .length;
                
            const dryDays = Object.entries(processedData.weather)
                .filter(([_, data]) => data.prcp <= 0.1)
                .length;
            
            // Calculate per-day rate
            const rainyRate = rainyDays > 0 ? rainyCount / rainyDays : 0;
            const dryRate = dryDays > 0 ? dryCount / dryDays : 0;
            
            // Calculate the relative change
            const ratio = Math.max(rainyRate, dryRate) / Math.max(0.1, Math.min(rainyRate, dryRate));
            const diff = Math.abs(rainyRate - dryRate);
            
            if (ratio > 1.3 && diff > 1) {
                precipSensitive.push({
                    complaint,
                    rainyRate,
                    dryRate,
                    ratio,
                    more: rainyRate > dryRate ? 'rainy' : 'dry'
                });
            }
        }
    });
    
    // Sort by ratio
    precipSensitive.sort((a, b) => b.ratio - a.ratio);
    
    // Create HTML output
    let html = '<div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-xs">';
    
    // Temperature findings
    html += '<div>';
    html += '<h4 class="font-medium mb-1">Temperature-Sensitive Complaints:</h4>';
    if (tempSensitive.length === 0) {
        html += '<p>Insufficient data to determine temperature correlation.</p>';
    } else {
        html += '<ul class="list-disc pl-4">';
        tempSensitive.forEach(item => {
            const maxFreq = Math.max(...item.frequencies.map(f => f.freq));
            const maxRange = item.frequencies.find(f => f.freq === maxFreq).range;
            
            html += `<li><span class="font-medium">${item.complaint}</span>: ${Math.round(item.spread * 10) / 10}x more frequent during <span class="font-medium">${maxRange}</span> weather</li>`;
        });
        html += '</ul>';
    }
    html += '</div>';
    
    // Precipitation findings
    html += '<div>';
    html += '<h4 class="font-medium mb-1">Precipitation-Sensitive Complaints:</h4>';
    if (precipSensitive.length === 0) {
        html += '<p>Insufficient data to determine precipitation correlation.</p>';
    } else {
        html += '<ul class="list-disc pl-4">';
        precipSensitive.slice(0, 5).forEach(item => {
            html += `<li><span class="font-medium">${item.complaint}</span>: ${Math.round(item.ratio * 10) / 10}x more frequent during <span class="font-medium">${item.more}</span> days</li>`;
        });
        html += '</ul>';
    }
    html += '</div>';
    
    html += '</div>';
    
    return html;
}

================================================================================


SUMMARY
Total files processed: 17
Total lines of code: 12735
